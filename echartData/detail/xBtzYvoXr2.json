{"status":0,"data":{"cid":"xBtzYvoXr2","authorUid":"obd-oCutVpdOdxqlXJT8JCaC62Xw9FpNk3X","authorUserName":"d***_","title":"正态分布拟合对比","description":"通过x轴概率和y轴数据拟态标准正态分布，与原图进行对比分析","latestVersion":8,"alwaysLatest":1,"createTime":"2020-04-10T06:20:00.000Z","lastUpdateTime":"2020-04-11T02:21:50.000Z","auth":2,"uid":"obd-oCutVpdOdxqlXJT8JCaC62Xw9FpNk3X","publishedVersion":0,"forkFrom":"-","isSpam":0,"version":8,"parentVersion":7,"echartsVersion":"4.7.0","versionCreateTime":"2020-05-13T03:07:07.000Z","code":"//相关详细说明：https://www.cnblogs.com/daxiongblog/p/12679363.html\nvar formulaCalcByFunc = function(formula, digit) {\n    var pow = Math.pow(10, digit);\n    return parseInt(formula * pow, 10) / pow;\n};\n\nfunction gaussFunc(x, xMaxi, yMaxi, s) {\n    return yMaxi * math.exp(-((x - xMaxi) * (x - xMaxi) / s));\n}\n/**\n* 标准正态分布函数\n* @@param x 数据\n* @@param mean 平均数\n* @@param stdev 标准差\n*/\nfunction normalDistributionfun(x, mean, stdev) {\n    return (1 / (Math.sqrt(2 * Math.PI) * stdev)) * Math.exp(-1 * ((x - mean) * (x - mean)) / (2 * stdev * stdev));\n}\n\n/**第二种方法： 使用标准正态分布函数实现的方法，通过在峰值周围寻找均值\n**结果将会偏向原始数据峰值\n****/\nfunction calcNormallineDta2(xData, yData) {\n            var result = [];\n         \n            var totalCount = 0;\n\n            var firstMode = 0;//峰值起始位置\n            var modeCount = 0;//找到目前数据的峰值\n        \n            for (var i = 0; i < yData.length;i++) {\n                totalCount += yData[i];\n                if (yData[i] > modeCount) {\n                    modeCount = yData[i];\n                    firstMode = i;\n                }\n             \n            }\n            //找出出x轴左右范围内的均值(关键代码)\n            var mode = 0;\n            var modeDuplicates = 0;\n        \n            var fellOffTop = true;\n\n            for (var j = firstMode; j < yData.length; j ++) {\n                if (yData[j] > yData[firstMode] - (yData[firstMode]/10)) {//10：分布线系数\n                    mode += j ;\n                    modeDuplicates++;\n                }\n                else {\n                    fellOffTop = false;\n                    break;\n                }\n            }\n\n            var fellOffBottom = true;\n        \n            for (var k=firstMode-1;k>=0;k--) {\n                if (yData[k] > yData[firstMode] - (yData[firstMode] / 10)) {//10：分布线系数\n                    mode += k;\n                    modeDuplicates++;\n                }\n                else {\n                    fellOffBottom = false;\n                    break;\n                }\n            }\n            var mean;\n            if (fellOffBottom || fellOffTop) {\n               \n                mean = firstMode;\n            }\n            else {\n                mean = mode/ modeDuplicates;\n            }\n            //求出标准差\n          \n            var stdev = 0;\n        \n            for (var n = 0; n < yData.length;n++) {\n                stdev += Math.pow((n - mean), 2) * yData[n];\n            }\n        \n            stdev /= totalCount-1;\n        \n            stdev = Math.sqrt(stdev);\n            //带入正态分布公式\n            for (var m = 0; m < yData.length;m++) {\n                var probability =normalDistributionfun(m,mean,stdev);\n                result.push(Math.round(probability * totalCount*100)/100);\n            }\n            return result;\n        }\n      \nvar yData = [\n    //12, 18.5, 37, 49, 66, 96.5, 118.5, 152.5, 215.5, 301.5, 403.5, 561, 876.5, 1328, 2017, 3374, 5478, 8938, 14880, 23522.5, 35697.5, 52651, 74815, 103371, 138536, 179551, 226008.5, 277843, 334386.5, 393973.5, 455601, 519580.5, 587045.5, 656523.5, 726978, 798408.5, 872569.5, 949706, 1022758, 1088846.5, 1149543.5, 1203080.5, 1247561, 1286516.5, 1320628, 1344814, 1357527, 1365572, 1375075.5, 1390487.5, 1407814, 1422297, 1432251.5, 1437508.5, 1437575, 1426377, 1409143, 1381505, 1335454, 1280151.5, 1219327.5, 1151028.5, 1075104, 989740.5, 892589, 784644.5, 678118.5, 579388.5, 486477.5, 401252, 326401.5, 260947.5, 205139.5, 159754, 122746, 94782.5, 73813.5, 57018, 44220, 34231.5, 26245.5, 20156, 15339.5, 11284, 8157, 5945, 4234, 2827.5, 1881, 1235, 772.5, 483.5, 298.5, 177.5, 108, 64.5, 44, 38, 61.5, 47.5, 7\n    53, 53, 58.5, 78, 115, 154.5, 200, 300.5, 383.5, 518, 871.5, 1382.5, 2192.5, 3340.5, 5249, 8979.5, 15448, 26225, 44057.5, 71392, 109113, 159006, 224595.5, 307191.5, 405623, 520332, 646965.5, 785170.5, 930962.5, 1078572.5, 1227179.5, 1373870, 1522723.5, 1671622.5, 1812839.5, 1944963, 2068185, 2180604.5, 2280685.5, 2361196.5, 2417123.5, 2457786, 2483891, 2494890, 2496943.5, 2498862.5, 2500857.5, 2500175, 2501485, 2499141, 2492862, 2478390, 2459869.5, 2443707, 2430140, 2421345.5, 2404805, 2377592.5, 2334130, 2263164, 2163510.5, 2031018.5, 1872739.5, 1698482, 1507286, 1306381.5, 1114865.5, 938499, 771654.5, 619227.5, 488654.5, 379699.5, 289925.5, 218837.5, 165510.5, 126806, 97552, 75560, 59062, 46304.5, 36476, 28583, 22280.5, 16965.5, 12631.5, 9265.5, 6629, 4548.5, 3091, 2102.5, 1396.5, 921, 580, 345, 203.5, 137, 87, 46, 27.5, 12, 6\n]\nvar xData = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\", \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\", \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\", \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\", \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\", \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\", \"100\"]\nvar datas2 = [];\nvar yData2 = [];\nvar yArr = [];\nvar xArr = xData.map(n => parseInt(n));\nvar sumFuc = (s, c) => formulaCalcByFunc(s + c, 6);\nvar len = xArr.length;\nvar ysum = yData.reduce(sumFuc, 0);\nfor (var n = 0; n < yData.length; n++) {\n    //var d = (dataArr[i] - mathCalcResult.avg) / mathCalcResult.stdDev;\n    var y = yData[n] / ysum;\n    yArr.push(y);\n}\nvar avg = math.mean(yArr);\n\nfunction gaussFit(xOriginal, yOriginal, average) {\n    var x = [];\n    var y = [];\n    // 过滤平滑部分\n    for (var i = 0; i < yOriginal.length; i++) { \n        if (yOriginal[i] > average) {\n        x.push(xOriginal[i]);\n        y.push(yOriginal[i]);\n        }\n    }\n    \n    var zMatrix = math.matrix(math.log(y));\n    var zMatrixT =zMatrix;\n\n    var xMatrix = math.ones([y.length, 3]);\n    //[1,x,x*x]\n    for (var j = 0; j < y.length; j++) {\n        xMatrix[j][1] = x[j];\n        xMatrix[j][2] = x[j] * x[j];\n    }\n    // 最小二乘法\n    var xMatrixT = math.transpose(xMatrix);\n    var bMatrix = math.multiply(math.multiply(math.inv(math.multiply(xMatrixT,\n        xMatrix)), xMatrixT), zMatrixT);\n    // 取值\n    var b2 = math.subset(bMatrix, math.index(2));\n    var b1 = math.subset(bMatrix, math.index(1));\n    var b0 = math.subset(bMatrix, math.index(0));\n\n    var s = -1 / b2;\n    var xMaxi = s * b1 / 2;\n    var yMaxi = math.exp(b0 + xMaxi * xMaxi / s);\n\n    var yFit = []\n    for (var n = 0; n < yOriginal.length; n++) {\n        yFit.push(gaussFunc(xOriginal[n], xMaxi, yMaxi, s));\n    }\n\n    return yFit;\n}\ndatas2 = gaussFit(xArr, yArr, avg);\nfor (var k = 0; k < datas2.length; k++) {\n    var l = datas2[k] / yArr[k];\n    //var d = (dataArr[i] - mathCalcResult.avg) / mathCalcResult.stdDev;\n    var y = yData[k] * l;\n    yData2.push(y);\n}\n\nvar colors = ['#7CCD7C', '#d14a61', '#675bba'];\noption = {\n    color: colors,\n\n    tooltip: {\n        trigger: 'axis',\n        axisPointer: {\n            type: 'cross'\n        }\n    },\n    grid: {\n        right: '20%'\n    },\n    toolbox: {\n        feature: {\n            dataView: {\n                show: true,\n                readOnly: false\n            },\n            restore: {\n                show: true\n            },\n            saveAsImage: {\n                show: true\n            }\n        }\n    },\n    legend: {\n        data: ['原数据', '正态分布']\n    },\n    xAxis: [{\n        type: 'category',\n        axisTick: {\n            alignWithLabel: true\n        },\n        data: xData\n    }],\n    yAxis: [{\n            type: 'value',\n            name: '原数据',\n            position: 'left'\n\n        },\n        {\n            type: 'value',\n            position: 'right'\n        }\n    ],\n    series: [{\n            name: '原数据',\n            type: 'line',\n            animation: false,\n            showSymbol: false,\n            itemStyle: {\n                color: \"red\"\n            },\n            data: yData\n        },\n        {\n            name: '正态分布',\n            type: 'line',\n            smooth: true,\n            data: yData2\n        }\n\n    ]\n};","html":"","externalScripts":"https://cdnjs.cloudflare.com/ajax/libs/mathjs/6.6.2/math.min.js","updaterUID":"obd-oCutVpdOdxqlXJT8JCaC62Xw9FpNk3X","theme":"default","layout":"","viewCount":1976,"userName":"d***_","commentCount":1,"starCount":4,"isStared":0,"thumbnailURL":"https://www.makeapie.com/ecg-storage/ec_gallery_thumbnail/xBtzYvoXr2.png?v=1589339228003","isCustomThumbnail":0,"builtinTags":["category-work","grid","legend","series-line","toolbox","tooltip"],"customTags":["normaldistribution","拟合","正态分布"],"updaterUserName":"d***_"}}