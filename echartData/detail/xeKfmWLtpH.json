{"status":0,"data":{"cid":"xeKfmWLtpH","authorUid":"obd-o2Xu1AJ-eOfrwy4_CP_ocx5Xyq6ndBK","authorUserName":"深***子","title":"仪表盘模拟角度渐变","description":"将rgb颜色切成多份填充，","latestVersion":9,"alwaysLatest":1,"createTime":"2020-09-01T01:23:29.000Z","lastUpdateTime":"2020-09-01T01:23:29.000Z","auth":2,"uid":"obd-o2Xu1AJ-eOfrwy4_CP_ocx5Xyq6ndBK","publishedVersion":0,"forkFrom":"-","isSpam":0,"version":9,"parentVersion":8,"echartsVersion":"4.8.0","versionCreateTime":"2020-09-02T13:19:26.000Z","code":"/*\r\n* 角度(圆锥)渐变\r\n* 原理: 使用axisLine的color来模拟实现, 平滑的渐变过渡借助axisTick实现.\r\n* 其他方案: axisTick的color设为image, 用角度渐变图片填充. \r\n          1.当使用ps生成的png图片时,此方案的问题是需要保持echarts大小不变,\r\n          尺寸一旦变化就需要修改图片的分辨率, 和裁剪图片,适应场景有限制\r\n*         2. 为了解除ps的限制,可以使用canvas的create-conical-gradient polyfill\r\n          根据echarts尺寸以及仪表盘radius动态生成角度渐变的图片填充在axisTick中\r\n* \r\n* 不均匀刻度\r\n* 原理：通过计算每个splitNumber的单位刻度值实现，公式在81行parseValue方法\r\n*/\r\n\r\n// 角度渐变的关键色值，在ps中获取\r\n// 一定要注意ps中角度渐变的起始角度要保持和图形的起始角度(startAngle)一致\r\nconst colors = [\r\n    [0, 235, 15, 15],\r\n    [0.1, 235, 15, 15],\r\n    [0.16, 255, 246, 0],\r\n    [0.4, 15, 235, 103],\r\n    [0.54, 15, 235, 103],\r\n    [0.67, 255, 246, 0],\r\n    [0.78, 235, 15, 15],\r\n    [0.9, 0, 99, 177],\r\n    [1, 235, 15, 15],\r\n];\r\n\r\n// 将如: 0.04-0.16之间的渐变值补全\r\nconst gradientColors = [];\r\ncolors.forEach((color, i) => {\r\n    if (i === colors.length - 1) return;\r\n    let maxDiffValue = 0;\r\n    const diffs = color.map((s, j) => {\r\n        const diff = s - colors[i + 1][j];\r\n        const positiveDiff = Math.abs(diff);\r\n        if (Math.abs(maxDiffValue) < positiveDiff) {\r\n            maxDiffValue = positiveDiff;\r\n        }\r\n        return diff;\r\n    });\r\n    gradientColors.push([color[0], `rgb(${color.slice(1).join(',')})`]);\r\n    let start = color[0];\r\n    const end = colors[i + 1][0];\r\n    const step = (end - start) / maxDiffValue;\r\n    for (let k = 0; k < maxDiffValue - 1; k++) {\r\n        let rgb = 'rgb($0,$1,$2)';\r\n        for (let o = 1; o < color.length; o++) {\r\n            let c = color[o];\r\n            c = c - diffs[o] / maxDiffValue;\r\n            color[o] = c;\r\n            rgb = rgb.replace(`$${o - 1}`, c);\r\n        }\r\n        start = start + step;\r\n        gradientColors.push([start, rgb]);\r\n    }\r\n});\r\nconst lastColor = colors[colors.length - 1];\r\ngradientColors.push([lastColor[0], `rgb(${lastColor.slice(1).join(',')})`]);\r\n\r\n// 测试数据\r\nconst testData = {\r\n    startAngle: 225,\r\n    endAngle: -45,\r\n    splitNumber: 6,\r\n    max: 65,\r\n    data: [30],\r\n};\r\n\r\n// 仪表盘axisLabel展示的值,个数为splitNumber + 1\r\nconst axisLabelData = [0, 40, 45, 50, 55, 60, 65];\r\n// 仪表盘axisLabel根据splitNumber生成的值\r\nconst axisLabelOriginData = (() => {\r\n    const data = [];\r\n    for (let index = 0; index < testData.splitNumber + 1; index++) {\r\n        //  echarts自动计算axisLabel时, 精确的是10位小数\r\n        data.push(+((testData.max / testData.splitNumber) * index).toFixed(10));\r\n    }\r\n    return data;\r\n})();\r\n\r\n// 将正常值转为指针偏转的值\r\nfunction parseValue(x, [kp, kn], [zp, zn]) {\r\n    if (x === 0) return 0;\r\n    const y = ((zn - zp) / (kn - kp)) * (x - kp) + zp;\r\n    return y;\r\n}\r\nlet value = testData.data[0];\r\nlet valueIndex = -1;\r\naxisLabelData.some((item, index) => {\r\n    valueIndex = index;\r\n    return value <= item;\r\n});\r\nconst k = [axisLabelData[valueIndex - 1], axisLabelData[valueIndex]];\r\nconst z = [axisLabelOriginData[valueIndex - 1], axisLabelOriginData[valueIndex]];\r\nvalue = parseValue(value, k, z);\r\n\r\n// 外层渐变圆环\r\nconst baseOut = {\r\n    type: 'gauge',\r\n    axisLabel: {\r\n        show: false,\r\n    },\r\n    axisLine: {\r\n        show: false,\r\n        lineStyle: {\r\n            color: gradientColors, // 因为使用axisLine填充的颜色之间会存在透明间隔, 所以使用axisTick来实现渐变平滑过渡.\r\n        },\r\n    },\r\n    axisTick: {\r\n        length: 4,\r\n        lineStyle: {\r\n            color: 'auto',\r\n            width: 2, // 调整width和splitNumber来使渐变平滑过渡\r\n        },\r\n        splitNumber: 150, // 调整width和splitNumber来使渐变平滑过渡\r\n    },\r\n    splitLine: {\r\n        show: false,\r\n        lineStyle: {\r\n            color: 'auto',\r\n        },\r\n    },\r\n    detail: {\r\n        show: false,\r\n    },\r\n};\r\n// 内层刻度和指针\r\nconst baseInner = {\r\n    radius: '70%',\r\n    type: 'gauge',\r\n    axisLine: {\r\n        show: false,\r\n        lineStyle: {\r\n            color: gradientColors,\r\n        },\r\n    },\r\n    splitLine: {\r\n        length: 12,\r\n        lineStyle: {\r\n            color: 'auto',\r\n        },\r\n    },\r\n    axisTick: {\r\n        lineStyle: {\r\n            width: 2,\r\n            color: 'auto',\r\n        },\r\n        splitNumber: 10,\r\n    },\r\n    pointer: {\r\n        width: 5,\r\n        length: '70%',\r\n    },\r\n    axisLabel: {\r\n        formatter(value) {\r\n            const index = axisLabelOriginData.findIndex((item) => item === value);\r\n            return axisLabelData[index];\r\n        },\r\n    },\r\n};\r\noption = {\r\n    series: [\r\n        baseOut,\r\n        {\r\n            ...baseInner,\r\n            ...testData,\r\n            data: [value],\r\n            detail: {\r\n                // 只支持字符串和函数\r\n                formatter: String(testData.data[0]),\r\n            },\r\n        },\r\n    ],\r\n};","html":"","externalScripts":"","updaterUID":"obd-o2Xu1AJ-eOfrwy4_CP_ocx5Xyq6ndBK","theme":"","layout":"","viewCount":159,"userName":"深***子","commentCount":0,"starCount":0,"isStared":0,"thumbnailURL":"https://www.makeapie.com/ecg-storage/ec_gallery_thumbnail/xeKfmWLtpH.png?v=1599052766941","isCustomThumbnail":0,"builtinTags":["category-work","series-gauge"],"customTags":["gauge"],"updaterUserName":"深***子"}}