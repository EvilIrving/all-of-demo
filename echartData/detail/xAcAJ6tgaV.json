{"status":0,"data":{"cid":"xAcAJ6tgaV","authorUid":"obd-otBkcV3qP49bbx1vf-8xtVXISLv5n8z","authorUserName":"8***0","title":"正太分布取中间","description":"","latestVersion":3,"alwaysLatest":0,"createTime":"2021-12-22T06:28:12.000Z","lastUpdateTime":"2022-01-18T08:54:27.000Z","auth":2,"uid":"obd-otBkcV3qP49bbx1vf-8xtVXISLv5n8z","publishedVersion":0,"forkFrom":"-","isSpam":0,"version":3,"parentVersion":2,"echartsVersion":"5.2.2","versionCreateTime":"2022-01-18T08:54:27.000Z","code":"//相关详细说明：https://www.cnblogs.com/daxiongblog/p/12679363.html\nvar formulaCalcByFunc = function (formula, digit) {\n    var pow = Math.pow(10, digit);\n    return parseInt(formula * pow, 10) / pow;\n};\n\nfunction gaussFunc(x, xMaxi, yMaxi, s) {\n    return yMaxi * math.exp(-(((x - xMaxi) * (x - xMaxi)) / s));\n}\n/**\n * 标准正态分布函数\n * @@param x 数据\n * @@param mean 平均数\n * @@param stdev 标准差\n */\nfunction normalDistributionfun(x, mean, stdev) {\n    return (1 / (Math.sqrt(2 * Math.PI) * stdev)) * Math.exp((-1 * ((x - mean) * (x - mean))) / (2 * stdev * stdev));\n}\n\n/**第二种方法： 使用标准正态分布函数实现的方法，通过在峰值周围寻找均值\n **结果将会偏向原始数据峰值\n ****/\nfunction calcNormallineDta2(xData, yData) {\n    var result = [];\n\n    var totalCount = 0;\n\n    var firstMode = 0; //峰值起始位置\n    var modeCount = 0; //找到目前数据的峰值\n\n    for (var i = 0; i < yData.length; i++) {\n        totalCount += yData[i];\n        if (yData[i] > modeCount) {\n            modeCount = yData[i];\n            firstMode = i;\n        }\n    }\n    //找出出x轴左右范围内的均值(关键代码)\n    var mode = 0;\n    var modeDuplicates = 0;\n\n    var fellOffTop = true;\n\n    for (var j = firstMode; j < yData.length; j++) {\n        if (yData[j] > yData[firstMode] - yData[firstMode] / 10) {\n            //10：分布线系数\n            mode += j;\n            modeDuplicates++;\n        } else {\n            fellOffTop = false;\n            break;\n        }\n    }\n\n    var fellOffBottom = true;\n\n    for (var k = firstMode - 1; k >= 0; k--) {\n        if (yData[k] > yData[firstMode] - yData[firstMode] / 10) {\n            //10：分布线系数\n            mode += k;\n            modeDuplicates++;\n        } else {\n            fellOffBottom = false;\n            break;\n        }\n    }\n    var mean;\n    if (fellOffBottom || fellOffTop) {\n        mean = firstMode;\n    } else {\n        mean = mode / modeDuplicates;\n    }\n    //求出标准差\n\n    var stdev = 0;\n\n    for (var n = 0; n < yData.length; n++) {\n        stdev += Math.pow(n - mean, 2) * yData[n];\n    }\n\n    stdev /= totalCount - 1;\n\n    stdev = Math.sqrt(stdev);\n    //带入正态分布公式\n    for (var m = 0; m < yData.length; m++) {\n        var probability = normalDistributionfun(m, mean, stdev);\n        result.push(Math.round(probability * totalCount * 100) / 100);\n    }\n    return result;\n}\n\nvar yData = [\n    53,\n    53,\n    58.5,\n    78,\n    115,\n    154.5,\n    200,\n    300.5,\n    383.5,\n    518,\n    871.5,\n    1382.5,\n    2192.5,\n    3340.5,\n    5249,\n    8979.5,\n    15448,\n    26225,\n    44057.5,\n    71392,\n    109113,\n    159006,\n    224595.5,\n    307191.5,\n    405623,\n    520332,\n    646965.5,\n    785170.5,\n    930962.5,\n    1078572.5,\n    1227179.5,\n    1373870,\n    1522723.5,\n    1671622.5,\n    1812839.5,\n    1944963,\n    2068185,\n    2180604.5,\n    2280685.5,\n    2361196.5,\n    2417123.5,\n    2457786,\n    2483891,\n    2494890,\n    2496943.5,\n    2498862.5,\n    2500857.5,\n    2500175,\n    2501485,\n    2499141,\n    2492862,\n    2478390,\n    2459869.5,\n    2443707,\n    2430140,\n    2421345.5,\n    2404805,\n    2377592.5,\n    2334130,\n    2263164,\n    2163510.5,\n    2031018.5,\n    1872739.5,\n    1698482,\n    1507286,\n    1306381.5,\n    1114865.5,\n    938499,\n    771654.5,\n    619227.5,\n    488654.5,\n    379699.5,\n    289925.5,\n    218837.5,\n    165510.5,\n    126806,\n    97552,\n    75560,\n    59062,\n    46304.5,\n    36476,\n    28583,\n    22280.5,\n    16965.5,\n    12631.5,\n    9265.5,\n    6629,\n    4548.5,\n    3091,\n    2102.5,\n    1396.5,\n    921,\n    580,\n    345,\n    203.5,\n    137,\n    87,\n    46,\n    27.5,\n    12,\n    6,\n];\nvar xData = [\n    '0',\n    '1',\n    '2',\n    '3',\n    '4',\n    '5',\n    '6',\n    '7',\n    '8',\n    '9',\n    '10',\n    '11',\n    '12',\n    '13',\n    '14',\n    '15',\n    '16',\n    '17',\n    '18',\n    '19',\n    '20',\n    '21',\n    '22',\n    '23',\n    '24',\n    '25',\n    '26',\n    '27',\n    '28',\n    '29',\n    '30',\n    '31',\n    '32',\n    '33',\n    '34',\n    '35',\n    '36',\n    '37',\n    '38',\n    '39',\n    '40',\n    '41',\n    '42',\n    '43',\n    '44',\n    '45',\n    '46',\n    '47',\n    '48',\n    '49',\n    '50',\n    '51',\n    '52',\n    '53',\n    '54',\n    '55',\n    '56',\n    '57',\n    '58',\n    '59',\n    '60',\n    '61',\n    '62',\n    '63',\n    '64',\n    '65',\n    '66',\n    '67',\n    '68',\n    '69',\n    '70',\n    '71',\n    '72',\n    '73',\n    '74',\n    '75',\n    '76',\n    '77',\n    '78',\n    '79',\n    '80',\n    '81',\n    '82',\n    '83',\n    '84',\n    '85',\n    '86',\n    '87',\n    '88',\n    '89',\n    '90',\n    '91',\n    '92',\n    '93',\n    '94',\n    '95',\n    '96',\n    '97',\n    '98',\n    '99',\n    '100',\n];\nvar datas2 = [];\nvar yData2 = [];\nvar yArr = [];\nvar xArr = xData.map((n) => parseInt(n));\nvar sumFuc = (s, c) => formulaCalcByFunc(s + c, 6);\nvar len = xArr.length;\nvar ysum = yData.reduce(sumFuc, 0);\nfor (var n = 0; n < yData.length; n++) {\n    //var d = (dataArr[i] - mathCalcResult.avg) / mathCalcResult.stdDev;\n    var y = yData[n] / ysum;\n    yArr.push(y);\n}\nvar avg = math.mean(yArr);\n\nfunction gaussFit(xOriginal, yOriginal, average) {\n    var x = [];\n    var y = [];\n    // 过滤平滑部分\n    for (var i = 0; i < yOriginal.length; i++) {\n        if (yOriginal[i] > average) {\n            x.push(xOriginal[i]);\n            y.push(yOriginal[i]);\n        }\n    }\n\n    var zMatrix = math.matrix(math.log(y));\n    var zMatrixT = zMatrix;\n\n    var xMatrix = math.ones([y.length, 3]);\n    //[1,x,x*x]\n    for (var j = 0; j < y.length; j++) {\n        xMatrix[j][1] = x[j];\n        xMatrix[j][2] = x[j] * x[j];\n    }\n    // 最小二乘法\n    var xMatrixT = math.transpose(xMatrix);\n    var bMatrix = math.multiply(math.multiply(math.inv(math.multiply(xMatrixT, xMatrix)), xMatrixT), zMatrixT);\n    // 取值\n    var b2 = math.subset(bMatrix, math.index(2));\n    var b1 = math.subset(bMatrix, math.index(1));\n    var b0 = math.subset(bMatrix, math.index(0));\n\n    var s = -1 / b2;\n    var xMaxi = (s * b1) / 2;\n    var yMaxi = math.exp(b0 + (xMaxi * xMaxi) / s);\n\n    var yFit = [];\n    for (var n = 0; n < yOriginal.length; n++) {\n        yFit.push(gaussFunc(xOriginal[n], xMaxi, yMaxi, s));\n    }\n\n    return yFit;\n}\ndatas2 = gaussFit(xArr, yArr, avg);\nfor (var k = 0; k < datas2.length; k++) {\n    var l = datas2[k] / yArr[k];\n    //var d = (dataArr[i] - mathCalcResult.avg) / mathCalcResult.stdDev;\n    var y = yData[k] * l;\n    yData2.push(y);\n    //yData2.push(y.toFixed(2));\n}\n\nvar colors = ['#7CCD7C', '#d14a61', '#675bba'];\noption = {\n    color: colors,\n\n    tooltip: {\n        trigger: 'axis',\n        axisPointer: {\n            type: 'cross',\n        },\n    },\n    grid: {\n        right: '20%',\n    },\n    toolbox: {\n        feature: {\n            dataView: {\n                show: true,\n                readOnly: false,\n            },\n            restore: {\n                show: true,\n            },\n            saveAsImage: {\n                show: true,\n            },\n        },\n    },\n    legend: {\n        data: ['原数据', '正态分布'],\n    },\n    xAxis: [\n        {\n            type: 'category',\n            boundaryGap: false,\n            axisTick: {\n                alignWithLabel: true,\n            },\n            data: xData,\n        },\n    ],\n    yAxis: [\n        {\n            type: 'value',\n            name: '原数据',\n            position: 'left',\n        },\n        {\n            type: 'value',\n            position: 'right',\n        },\n    ],\n    visualMap: [\n        {},\n        {\n            type: 'piecewise',\n            show: false,\n            dimension: 0,\n            seriesIndex: 1,\n            pieces: [\n                {\n                    gt: 27,\n                    lt: 69,\n                    color: 'rgba(0, 0, 180, 0.4)',\n                },\n            ],\n        },\n    ],\n    series: [\n        {\n            name: '原数据',\n            type: 'line',\n            animation: false,\n            showSymbol: false,\n            itemStyle: {\n                color: 'red',\n            },\n            areaStyle: {},\n            data: yData,\n        },\n        {\n            name: '正态分布',\n            type: 'line',\n            smooth: true,\n            markLine: {\n                symbol: ['none', 'none'],\n                label: { show: false },\n                data: [{ xAxis: 27 }, { xAxis: 69 }],\n            },\n            areaStyle: {},\n            data: yData2,\n        },\n    ],\n};\n","html":"","externalScripts":"https://cdnjs.cloudflare.com/ajax/libs/mathjs/6.6.2/math.min.js","updaterUID":"obd-otBkcV3qP49bbx1vf-8xtVXISLv5n8z","theme":"","layout":"","viewCount":0,"userName":"8***0","commentCount":0,"starCount":0,"isStared":0,"thumbnailURL":"https://www.makeapie.com/ecg-storage/ec_gallery_thumbnail/xAcAJ6tgaV.png?v=1642496067801","isCustomThumbnail":0,"builtinTags":["category-work","grid","legend","markLine","series-line","toolbox","tooltip","visualMap"],"customTags":[],"updaterUserName":"8***0"}}