{"status":0,"data":{"cid":"xyQV58zh6l","authorUid":"bd-101698999","authorUserName":"Z***8","title":"仿《自私的基因》，傻瓜、斤斤计较者、骗子策略模拟","description":"假设有一种非常令人厌恶的蜱寄生在某种小鸟身上，而这种蜱又带有某种危险的病菌，所以必须尽早消灭这些蜱。\n一般说来，小鸟用嘴梳理自己的羽毛时能够把蜱剔除掉，可是有一个鸟嘴达不到的地方——它的头顶。\n\nA.傻瓜策略：无论如何都帮助对方清理蜱\nB.骗子策略：无论如何都不帮助对方清理蜱\nC.斤斤计较策略：只帮助从未欺骗过自己的小鸟清理蜱","latestVersion":4,"alwaysLatest":0,"createTime":"2021-12-22T14:58:42.000Z","lastUpdateTime":"2021-12-22T15:15:01.000Z","auth":2,"uid":"bd-101698999","publishedVersion":0,"forkFrom":"-","isSpam":0,"version":4,"parentVersion":3,"echartsVersion":"5.2.2","versionCreateTime":"2021-12-22T15:15:02.000Z","code":"const seriesLayoutBy = 'row';\nconst seriesType = 'scatter';\nconst baseConfig = {\n  moveSpeed: 1,\n  childThreshold: 200,\n  maxAge: 200,\n\n  childCost: 60,\n  illLost: 30,\n  clearCost: 0.05,\n  selfRecoveryIncrease: 10,\n  balancePopulation: 1000,\n  illPR: 0.3,\n  distance: 1,\n  baseCount: 200,\n  rateA: 1,\n  rateB: 1,\n  rateC: 0.001,\n};\n\nfunction init(rateA, rateB, rateC) {\n  const baseCount = baseConfig.baseCount;\n\n  let ret = {\n    A: [],\n    B: [],\n    C: [],\n  };\n  let planA = {\n    clear: true,\n    ill: false,\n    child: 0,\n    age: 0,\n  };\n  let planB = {\n    clear: false,\n    ill: false,\n    child: 0,\n    age: 0,\n  };\n  let planC = {\n    clear: true,\n    ill: false,\n    child: 0,\n    age: 0,\n    except: {},\n  };\n\n  for (let i = 0; i < baseCount * rateA; i++) {\n    ret.A.push(['傻瓜', Math.random() * 10, Math.random() * 10, 100, 'A' + i, Object.assign({}, planA)]);\n  }\n  for (let i = 0; i < baseCount * rateB; i++) {\n    ret.B.push(['骗子', Math.random() * 10, Math.random() * 10, 100, 'B' + i, Object.assign({}, planB)]);\n  }\n  for (let i = 0; i < baseCount * rateC; i++) {\n    ret.C.push(['斤斤计较者', Math.random() * 10, Math.random() * 10, 100, 'C' + i, Object.assign({}, planC)]);\n  }\n  // console.log(ret);\n  return ret;\n}\n\nfunction emulate(src) {\n  let dst = {\n    A: [],\n    B: [],\n    C: [],\n  };\n\n  let srcArr = src.A.concat(src.B).concat(src.C);\n\n  // console.log(srcArr.length);\n\n  for (let i = srcArr.length - 1; i >= 0; i--) {\n    // 随机移动\n    srcArr[i][1] += (Math.random() - 0.5) * 2 * baseConfig.moveSpeed;\n    srcArr[i][2] += (Math.random() - 0.5) * 2 * baseConfig.moveSpeed;\n\n    // 移动超出范围则折返\n    srcArr[i][1] < 0\n      ? (srcArr[i][1] = 0 - srcArr[i][1])\n      : srcArr[i][1] > 10\n      ? (srcArr[i][1] = 20 - srcArr[i][1])\n      : null;\n    srcArr[i][2] < 0\n      ? (srcArr[i][2] = 0 - srcArr[i][2])\n      : srcArr[i][2] > 10\n      ? (srcArr[i][2] = 20 - srcArr[i][2])\n      : null;\n\n    // 随机生病\n    if (Math.random() <= baseConfig.illPR) {\n      // console.log('some one ill');\n      srcArr[i][5].ill = true;\n    }\n\n    // 生病减少生命值\n    if (srcArr[i][5].ill) {\n      tmpHealth = srcArr[i][3];\n      srcArr[i][3] -= baseConfig.illLost;\n      // console.log(`some one illcost: ${tmpHealth} -> ${srcArr[i][3]}(${baseConfig.illLost})`);\n    }\n\n    //寿命计算\n    srcArr[i][5].age < baseConfig.maxAge ? srcArr[i][5].age++ : (srcArr[i][3] = 0);\n\n    // 生命值归零则丢弃去掉\n    if (srcArr[i][3] <= 0) {\n      srcArr.splice(i, 1);\n\n      // 生命值大于阈值，则生育\n    } else if (srcArr[i][3] > baseConfig.childThreshold) {\n      srcArr[i][3] -= baseConfig.childCost;\n      srcArr[i][5].child += 1;\n      tmpPlan = Object.assign({}, srcArr[i][5]);\n      tmpPlan.ill = false;\n      tmpPlan.child = 0;\n      tmpPlan.age = 0;\n      tmpPlan.except ? (tmpPlan.except = {}) : null;\n      srcArr.push([srcArr[i][0], srcArr[i][1], srcArr[i][2], 100, `${srcArr[i][4]}_${srcArr[i][5].child}`, tmpPlan]);\n    }\n  }\n  // console.log(srcArr.length);\n  for (let i = 0; i < srcArr.length; i++) {\n    for (let j = i + 1; j < srcArr.length; j++) {\n      let dx = srcArr[i][1] - srcArr[j][1] > 0 ? srcArr[i][1] - srcArr[j][1] : srcArr[j][1] - srcArr[i][1];\n      let dy = srcArr[i][2] - srcArr[j][2] > 0 ? srcArr[i][2] - srcArr[j][2] : srcArr[j][2] - srcArr[i][2];\n\n      if (dx + dy > baseConfig.distance) {\n        continue; // 未达到相互作用距离（为了简化运算，未使用平方和来判断）\n      }\n\n      // 判断、清理、消耗、记仇（斤斤计较者未被清理）\n      srcArr[i][5].clear && !(srcArr[i][5].except && srcArr[i][5].except[srcArr[j][4]] > 0)\n        ? ((srcArr[j][5].ill = false), (srcArr[i][3] -= baseConfig.clearCost))\n        : typeof srcArr[j][5].except === 'undefined'\n        ? null\n        : (srcArr[j][5].except[srcArr[i][4]] = 1);\n\n      srcArr[j][5].clear && !(srcArr[j][5].except && srcArr[j][5].except[srcArr[i][4]] > 0)\n        ? ((srcArr[i][5].ill = false), (srcArr[j][3] -= baseConfig.clearCost))\n        : typeof srcArr[i][5].except === 'undefined'\n        ? null\n        : (srcArr[i][5].except[srcArr[j][4]] = 1);\n    }\n\n    // 正常恢复（个体数量超过平衡数量后，恢复值将与个体数量呈反比）\n    srcArr[i][3] +=\n      srcArr.length < baseConfig.balancePopulation\n        ? baseConfig.selfRecoveryIncrease\n        : Math.round((baseConfig.selfRecoveryIncrease * baseConfig.balancePopulation) / srcArr.length);\n\n    // 计算完毕，存入 dst\n    srcArr[i][4].startsWith('A')\n      ? dst.A.push(srcArr[i])\n      : srcArr[i][4].startsWith('B')\n      ? dst.B.push(srcArr[i])\n      : dst.C.push(srcArr[i]);\n  }\n  // console.log(dst);\n  return dst;\n}\n\nlet dataAll = init(baseConfig.rateA, baseConfig.rateB, baseConfig.rateC);\n\noption = {\n  title: {\n    show: true,\n    text: '仿《自私的基因》，傻瓜、斤斤计较者、骗子策略模拟',\n    subtext:\n      '假设有一种非常令人厌恶的蜱寄生在某种小鸟身上，而这种蜱又带有某种危险的病菌，所以必须尽早消灭这些蜱。\\n一般说来，小鸟用嘴梳理自己的羽毛时能够把蜱剔除掉，可是有一个鸟嘴达不到的地方——它的头顶。\\n\\nA.傻瓜策略：无论如何都帮助对方清理蜱\\nB.骗子策略：无论如何都不帮助对方清理蜱\\nC.斤斤计较策略：只帮助从未欺骗过自己的小鸟清理蜱',\n  },\n  dataset: [\n    {\n      sourceHeader: true,\n      // dimensions: ['seriesName', 'x', 'y', 'value', 'idx', 'obj'],\n      source: dataAll.A,\n    },\n    {\n      sourceHeader: true,\n      // dimensions: ['seriesName', 'x', 'y', 'value', 'idx', 'obj'],\n      source: dataAll.B,\n    },\n    {\n      sourceHeader: true,\n      // dimensions: ['seriesName', 'x', 'y', 'value', 'idx', 'obj'],\n      source: dataAll.C,\n    },\n    {\n      // dimensions: ['seriesName', 'count'],\n      source: (function () {\n        let sourceStats = [];\n        for (let key in dataAll) {\n          sourceStats.push([dataAll[key][0][0], dataAll[key].length]);\n        }\n        return sourceStats;\n      })(),\n    },\n  ],\n  grid: {\n    top: '20%',\n    bottom: '30%',\n  },\n  tooltip: {\n    formatter: (params) => {\n      if (params.seriesIndex === 3) {\n        return params.name + '：' + params.data[1];\n      }\n      // console.log(params);\n      return `${params.seriesName}<br />${params.data[4]}(${params.data[3]})<br />蜱：${params.data[5].ill}${\n        typeof params.data[5].except === 'undefined' || true\n          ? ''\n          : '<br />黑名单：' + Object.keys(params.data[5].except).join('<br/>')\n      }`;\n    },\n  },\n  legend: {\n    right: '5%',\n    top: '5%',\n  },\n  xAxis: {\n    max: 10,\n  },\n  yAxis: {\n    max: 10,\n  },\n  animation: false,\n  series: (function () {\n    let seriesList = [];\n    for (let i = 0; i < 3; i++) {\n      seriesList.push({\n        type: seriesType,\n        datasetIndex: i,\n        encode: {\n          seriesName: 0,\n          x: 1,\n          y: 2,\n          value: 3,\n        },\n      });\n    }\n    seriesList.push({\n      type: 'pie',\n      datasetIndex: 3,\n      xAxisIndex: 1,\n      yAxisIndex: 1,\n      seriesLayoutBy: 'column',\n      center: ['50%', '85%'],\n      startAngle: 0,\n      radius: [0, '20%'],\n      itemStyle: {\n        color: (params) => {\n          return params.name === '傻瓜' ? '#5470c6' : params.name === '骗子' ? '#91cc75' : '#fac858';\n        },\n      },\n      label: {\n        formatter: '{b}：{d}%',\n        alignTo: 'edge',\n      },\n      labelLayout: {\n        alignTo: 'edge',\n        draggable: true,\n      },\n    });\n    return seriesList;\n  })(),\n};\n\nlet timer = setInterval(function () {\n  // console.log(dataAll);\n  dataAll = emulate(dataAll);\n  console.log('emulate');\n\n  myChart.setOption({\n    dataset: [\n      {\n        source: dataAll.A,\n      },\n      {\n        source: dataAll.B,\n      },\n      {\n        source: dataAll.C,\n      },\n      {\n        source: (function () {\n          let sourceStats = [];\n          for (let key in dataAll) {\n            if (dataAll[key].length > 0) {\n              sourceStats.push([dataAll[key][0][0], dataAll[key].length]);\n            }\n          }\n          return sourceStats;\n        })(),\n      },\n    ],\n  });\n  if (dataAll.A.length === 0 && dataAll.B.length === 0 && dataAll.C.length === 0) {\n    clearInterval(timer);\n  }\n}, 100);\n\n// clearInterval(timer);\n","html":"","externalScripts":"https://cdn.jsdelivr.net/npm/echarts-gl@2/dist/echarts-gl.min.js","updaterUID":"bd-101698999","theme":"","layout":"","viewCount":0,"userName":"Z***8","commentCount":0,"starCount":0,"isStared":0,"thumbnailURL":"https://www.makeapie.com/ecg-storage/ec_gallery_thumbnail/xyQV58zh6l.png?v=1640186102149","isCustomThumbnail":0,"builtinTags":["category-work","dataset","grid","legend","series-pie","series-scatter","title","tooltip"],"customTags":["《自私的基因》"],"updaterUserName":"Z***8"}}