{"status":0,"data":{"cid":"xrJob_GZal","authorUid":"bd-2215764494","authorUserName":"p***g","title":"benchmark","description":"https://bl.ocks.org/pbeshai/65420c8d722cdbb0600b276c3adcc6e8#common.js\nhttps://bl.ocks.org/hudsonb/7beba51e38676fb6bafc0f266f7fa338\n","latestVersion":3,"alwaysLatest":1,"createTime":"2017-04-04T12:56:35.000Z","lastUpdateTime":"2017-06-11T07:24:39.000Z","auth":2,"uid":"bd-2215764494","publishedVersion":0,"forkFrom":"-","isSpam":0,"version":3,"parentVersion":2,"echartsVersion":"3.6.2","versionCreateTime":"2017-07-07T04:12:55.000Z","code":"\noption = {\n    series: []\n};\n\n/**\n * Given a set of points, lay them out in a phyllotaxis layout.\n * Mutates the `points` passed in by updating the x and y values.\n *\n * @param {Object[]} points The array of points to update. Will get `x` and `y` set.\n * @param {Number} pointWidth The size in pixels of the point's width. Should also include margin.\n * @param {Number} xOffset The x offset to apply to all points\n * @param {Number} yOffset The y offset to apply to all points\n *\n * @return {Object[]} points with modified x and y\n */\nfunction phyllotaxisLayout(points, pointWidth, xOffset = 0, yOffset = 0, iOffset = 0) {\n    // theta determines the spiral of the layout\n    var theta = Math.PI * (3 - Math.sqrt(5));\n\n    var pointRadius = pointWidth / 2;\n\n    points.forEach((point, i) => {\n        var index = (i + iOffset) % points.length;\n        var phylloX = pointRadius * Math.sqrt(index) * Math.cos(index * theta);\n        var phylloY = pointRadius * Math.sqrt(index) * Math.sin(index * theta);\n\n        point.x = xOffset + phylloX - pointRadius;\n        point.y = yOffset + phylloY - pointRadius;\n    });\n\n    return points;\n}\n\n/**\n * Given a set of points, lay them out in a grid.\n * Mutates the `points` passed in by updating the x and y values.\n *\n * @param {Object[]} points The array of points to update. Will get `x` and `y` set.\n * @param {Number} pointWidth The size in pixels of the point's width. Should also include margin.\n * @param {Number} gridWidth The width of the grid of points\n *\n * @return {Object[]} points with modified x and y\n */\nfunction gridLayout(points, pointWidth, gridWidth) {\n    var pointHeight = pointWidth;\n    var pointsPerRow = Math.floor(gridWidth / pointWidth);\n    var numRows = points.length / pointsPerRow;\n\n    points.forEach((point, i) => {\n        point.x = pointWidth * (i % pointsPerRow);\n        point.y = pointHeight * Math.floor(i / pointsPerRow);\n    });\n\n    return points;\n}\n\n/**\n * Given a set of points, lay them out randomly.\n * Mutates the `points` passed in by updating the x and y values.\n *\n * @param {Object[]} points The array of points to update. Will get `x` and `y` set.\n * @param {Number} pointWidth The size in pixels of the point's width. Should also include margin.\n * @param {Number} width The width of the area to place them in\n * @param {Number} height The height of the area to place them in\n *\n * @return {Object[]} points with modified x and y\n */\nfunction randomLayout(points, pointWidth, width, height) {\n    points.forEach((point, i) => {\n        point.x = Math.random() * (width - pointWidth);\n        point.y = Math.random() * (height - pointWidth);\n    });\n\n    return points;\n}\n\n/**\n * Given a set of points, lay them out in a sine wave.\n * Mutates the `points` passed in by updating the x and y values.\n *\n * @param {Object[]} points The array of points to update. Will get `x` and `y` set.\n * @param {Number} pointWidth The size in pixels of the point's width. Should also include margin.\n * @param {Number} width The width of the area to place them in\n * @param {Number} height The height of the area to place them in\n *\n * @return {Object[]} points with modified x and y\n */\nfunction sineLayout(points, pointWidth, width, height) {\n    var amplitude = 0.3 * (height / 2);\n    var yOffset = height / 2;\n    var periods = 3;\n    var yScale = d3.scaleLinear()\n        .domain([0, points.length - 1])\n        .range([0, periods * 2 * Math.PI]);\n\n    points.forEach((point, i) => {\n        point.x = (i / points.length) * (width - pointWidth);\n        point.y = amplitude * Math.sin(yScale(i)) + yOffset;\n    });\n\n    return points;\n}\n\n/**\n * Given a set of points, lay them out in a spiral.\n * Mutates the `points` passed in by updating the x and y values.\n *\n * @param {Object[]} points The array of points to update. Will get `x` and `y` set.\n * @param {Number} pointWidth The size in pixels of the point's width. Should also include margin.\n * @param {Number} width The width of the area to place them in\n * @param {Number} height The height of the area to place them in\n *\n * @return {Object[]} points with modified x and y\n */\nfunction spiralLayout(points, pointWidth, width, height) {\n    var amplitude = 0.3 * (height / 2);\n    var xOffset = width / 2;\n    var yOffset = height / 2;\n    var periods = 20;\n\n    var rScale = d3.scaleLinear()\n        .domain([0, points.length - 1])\n        .range([0, Math.min(width / 2, height / 2) - pointWidth]);\n\n    var thetaScale = d3.scaleLinear()\n        .domain([0, points.length - 1])\n        .range([0, periods * 2 * Math.PI]);\n\n    points.forEach((point, i) => {\n        point.x = rScale(i) * Math.cos(thetaScale(i)) + xOffset\n        point.y = rScale(i) * Math.sin(thetaScale(i)) + yOffset;\n    });\n\n    return points;\n}\n\n\n\n\n/**\n * Generate an object array of `numPoints` length with unique IDs\n * and assigned colors\n */\nfunction createPoints(numPoints, pointWidth, width, height) {\n    var colorScale = d3.scaleSequential(d3.interpolateViridis)\n        .domain([numPoints - 1, 0]);\n\n    var points = d3.range(numPoints).map(id => ({\n        id,\n        color: colorScale(id),\n    }));\n\n    return randomLayout(points, pointWidth, width, height);\n}\n\n// canvas settings\nvar width = myChart.getZr().getWidth();\nvar height = myChart.getZr().getHeight();\n\n// point settings\nvar numPoints = 7000;\nvar pointWidth = 3;\nvar pointMargin = 3;\n\n// animation settings\nvar duration = 1500;\nvar ease = d3.easeCubic;\nvar timer;\nvar currLayout = 0;\n\n// create set of points\nvar points = createPoints(numPoints, pointWidth, width, height);\n\n// wrap layout helpers so they only take points as an argument\nvar toGrid = (points) => gridLayout(points,\n    pointWidth + pointMargin, width);\nvar toSine = (points) => sineLayout(points,\n    pointWidth + pointMargin, width, height);\nvar toSpiral = (points) => spiralLayout(points,\n    pointWidth + pointMargin, width, height);\nvar toPhyllotaxis = (points) => phyllotaxisLayout(points,\n    pointWidth + pointMargin, width / 2, height / 2);\n\n// store the layouts in an array to sequence through\nvar layouts = [toSine, toPhyllotaxis, toSpiral, toPhyllotaxis, toGrid];\n\n// animate the points to a given layout\nfunction animate(rects, layout) {\n    // store the source position\n    points.forEach(point => {\n        point.sx = point.x;\n        point.sy = point.y;\n    });\n\n    // get destination x and y position on each point\n    layout(points);\n\n    // store the destination position\n    points.forEach(point => {\n        point.tx = point.x;\n        point.ty = point.y;\n    });\n\n    timer = d3.timer((elapsed) => {\n        // compute how far through the animation we are (0 to 1)\n        var t = Math.min(1, ease(elapsed / duration));\n\n        // update point positions (interpolate between source and target)\n        points.forEach(point => {\n            point.x = point.sx * (1 - t) + point.tx * t;\n            point.y = point.sy * (1 - t) + point.ty * t;\n        });\n\n        // update what is drawn on screen\n        rects.forEach(function(rect, idx) {\n            rect.setShape('x', rect.__point__.x);\n            rect.setShape('y', rect.__point__.y);\n        });\n\n        // if this animation is over\n        if (t === 1) {\n            // stop this timer for this layout and start a new one\n            timer.stop();\n\n            // update to use next layout\n            currLayout = (currLayout + 1) % layouts.length;\n\n            // start animation for next layout\n            animate(rects, layouts[currLayout]);\n        }\n    });\n}\nmyChart.getZr().clear();\nvar rects = points.map(function(pt) {\n    var rect = new echarts.graphic.Rect({\n        shape: {\n            width: pointWidth,\n            height: pointWidth\n        },\n        style: {\n            fill: pt.color\n        },\n        silent: true,\n        __point__: pt\n    });\n    myChart.getZr().add(rect);\n    return rect;\n});\n\n// start off as a grid\ntoGrid(points);\n\nrects.forEach(function(rect, idx) {\n    rect.setShape('x', rect.__point__.x);\n    rect.setShape('y', rect.__point__.y);\n});\n\nsetTimeout(function () {\n    // start the animation\n    animate(rects, layouts[currLayout]);\n}, 1000)\n","html":"","externalScripts":"https://d3js.org/d3.v4.min.js","updaterUID":"bd-2215764494","theme":"default","layout":"","viewCount":1383,"userName":"p***g","commentCount":0,"starCount":6,"isStared":0,"thumbnailURL":"https://www.makeapie.com/ecg-storage/ec_gallery_thumbnail/xrJob_GZal.png?v=1497165881382","isCustomThumbnail":1,"builtinTags":["category-work"],"customTags":[],"updaterUserName":"p***g"}}