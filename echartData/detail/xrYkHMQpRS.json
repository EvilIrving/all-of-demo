{"status":0,"data":{"cid":"xrYkHMQpRS","authorUid":"bd-1847551832","authorUserName":"s***0","title":"延指定路径移动的动画","description":"","latestVersion":5,"alwaysLatest":1,"createTime":"2020-05-18T07:29:45.000Z","lastUpdateTime":"2020-05-18T07:29:45.000Z","auth":2,"uid":"bd-1847551832","publishedVersion":0,"forkFrom":"-","isSpam":0,"version":5,"parentVersion":4,"echartsVersion":"4.7.0","versionCreateTime":"2020-05-18T09:32:05.000Z","code":"var symbolSize = 20;\nvar showControl = true\nvar data = [[0,0], [50,30], [120,180], [185,100], [250, 150], [255,255]];\nvar easing = 'bounceOut'\nvar during = 5000\nvar easingFuncs = {\n    linear: function (k) {\n        return k;\n    },\n    quadraticIn: function (k) {\n        return k * k;\n    },\n    quadraticOut: function (k) {\n        return k * (2 - k);\n    },\n    quadraticInOut: function (k) {\n        if ((k *= 2) < 1) { return 0.5 * k * k; }\n        return -0.5 * (--k * (k - 2) - 1);\n    },\n    cubicIn: function (k) {\n        return k * k * k;\n    },\n    cubicOut: function (k) {\n        return --k * k * k + 1;\n    },\n    cubicInOut: function (k) {\n        if ((k *= 2) < 1) { return 0.5 * k * k * k; }\n        return 0.5 * ((k -= 2) * k * k + 2);\n    },\n    quarticIn: function (k) {\n        return k * k * k * k;\n    },\n    quarticOut: function (k) {\n        return 1 - (--k * k * k * k);\n    },\n    quarticInOut: function (k) {\n        if ((k *= 2) < 1) { return 0.5 * k * k * k * k; }\n        return -0.5 * ((k -= 2) * k * k * k - 2);\n    },\n    quinticIn: function (k) {\n        return k * k * k * k * k;\n    },\n    quinticOut: function (k) {\n        return --k * k * k * k * k + 1;\n    },\n    quinticInOut: function (k) {\n        if ((k *= 2) < 1) { return 0.5 * k * k * k * k * k; }\n        return 0.5 * ((k -= 2) * k * k * k * k + 2);\n    },\n    sinusoidalIn: function (k) {\n        return 1 - Math.cos(k * Math.PI / 2);\n    },\n    sinusoidalOut: function (k) {\n        return Math.sin(k * Math.PI / 2);\n    },\n    sinusoidalInOut: function (k) {\n        return 0.5 * (1 - Math.cos(Math.PI * k));\n    },\n    exponentialIn: function (k) {\n        return k === 0 ? 0 : Math.pow(1024, k - 1);\n    },\n    exponentialOut: function (k) {\n        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n    },\n    exponentialInOut: function (k) {\n        if (k === 0) {\n            return 0;\n        }\n        if (k === 1) {\n            return 1;\n        }\n        if ((k *= 2) < 1) {\n            return 0.5 * Math.pow(1024, k - 1);\n        }\n        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n    },\n    circularIn: function (k) {\n        return 1 - Math.sqrt(1 - k * k);\n    },\n    circularOut: function (k) {\n        return Math.sqrt(1 - (--k * k));\n    },\n    circularInOut: function (k) {\n        if ((k *= 2) < 1) { return -0.5 * (Math.sqrt(1 - k * k) - 1); }\n        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n    },\n    elasticIn: function (k) {\n        var s;\n        var a = 0.1;\n        var p = 0.4;\n        if (k === 0) { return 0; }\n        if (k === 1) { return 1; }\n        if (!a || a < 1) { a = 1; s = p / 4; }\n        else { s = p * Math.asin(1 / a) / (2 * Math.PI); }\n        return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n    },\n    elasticOut: function (k) {\n        var s;\n        var a = 0.1;\n        var p = 0.4;\n        if (k === 0) { return 0; }\n        if (k === 1) { return 1; }\n        if (!a || a < 1) { a = 1; s = p / 4; }\n        else { s = p * Math.asin(1 / a) / (2 * Math.PI); }\n        return (a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n    },\n    elasticInOut: function (k) {\n        var s;\n        var a = 0.1;\n        var p = 0.4;\n        if (k === 0) { return 0; }\n        if (k === 1) { return 1; }\n        if (!a || a < 1) { a = 1; s = p / 4; }\n        else { s = p * Math.asin(1 / a) / (2 * Math.PI); }\n        if ((k *= 2) < 1) {\n            return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n        }\n        return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n    },\n\n    // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n    backIn: function (k) {\n        var s = 1.70158;\n        return k * k * ((s + 1) * k - s);\n    },\n    backOut: function (k) {\n        var s = 1.70158;\n        return --k * k * ((s + 1) * k + s) + 1;\n    },\n    backInOut: function (k) {\n        var s = 1.70158 * 1.525;\n        if ((k *= 2) < 1) { return 0.5 * (k * k * ((s + 1) * k - s)); }\n        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n    },\n\n    // 创建弹跳效果\n    bounceIn: function (k) {\n        return 1 - easingFuncs.bounceOut(1 - k);\n    },\n    bounceOut: function (k) {\n        if (k < (1 / 2.75)) { return 7.5625 * k * k; }\n        else if (k < (2 / 2.75)) { return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75; }\n        else if (k < (2.5 / 2.75)) { return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375; }\n        else { return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375; }\n    },\n    bounceInOut: function (k) {\n        if (k < 0.5) { return easingFuncs.bounceIn(k * 2) * 0.5; }\n        return easingFuncs.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n    }\n};\nvar smooth = 100\n\nvar animate = {\n    _i: 0,\n    _runTimes: 1,\n    _timer: null,\n    _points: [],\n    _easingFunc: null,\n    _always: true,\n    disable: false,\n    _timeout: 20,\n    start(path = [], easing='linear', during=2500, always = true) {\n        if (this._t) {\n            clearTimeout(this._t)\n        }\n        this._t = setTimeout(() => {\n            const length = path.length - 1\n            let runTimes = Math.round(during / this._timeout)\n            if (runTimes > length) {\n                runTimes = length\n            }\n            if (this._timer) {\n                clearTimeout(this._timer)\n                this._timer = null\n            }\n            this._easingFunc = easingFuncs[easing]\n            this._runTimes = runTimes\n            this._points = path\n            this._i = 0\n            this._always = always\n            this.disable = false\n            this._run()\n            console.log(this) \n        }, 300)\n    },\n    _run() {\n        if (this.disable) {\n            return\n        }\n        const t = this._easingFunc(this._i / this._runTimes)\n        const points = this._points\n        const length = points.length - 1\n        let current = points[0]\n        if (t < 0) {\n            current = [points[0][0] - 10 * t, points[1] -10 * t]\n        } else if (t > 1) {\n            current = [points[length][0] + 10 * t, points[length][1] + 10 * t]\n        } else {\n            current = points[Math.round(t * length)]\n        }\n        // console.log(Math.round(t * length), t, this._i, this._runTimes, current)\n        myChart.setOption({\n            graphic: [...echarts.util.map(data, function (item, dataIndex) {\n                return {\n                    type: 'circle',\n                    position: myChart.convertToPixel('grid', item),\n                    shape: {\n                        cx: 0,\n                        cy: 0,\n                        r: symbolSize / 2\n                    },\n                    invisible: true,\n                    draggable: true,\n                    ondrag: echarts.util.curry(onPointDragging, dataIndex),\n                    onmousemove: echarts.util.curry(showTooltip, dataIndex),\n                    onmouseout: echarts.util.curry(hideTooltip, dataIndex),\n                    onclick: echarts.util.curry(removePoint, dataIndex),\n                    z: 100\n                };\n            }), {\n                type: 'rect',\n                position: myChart.convertToPixel('grid', current),\n                shape: {\n                    x: -symbolSize/2,\n                    y: -symbolSize/2,\n                    width: symbolSize,\n                    height: symbolSize\n                },\n                style: {\n                    fill: 'green'\n                },\n                z: 200\n            }]\n        })\n        \n        this._i++\n        if (this._i > this._runTimes) {\n            if (this._always) {\n                this._i = 0\n            } else {\n                return\n            }\n        }\n        this._timer = setTimeout(() => {\n            this._run()\n        }, this._timout)\n    },\n    stop() {\n        this.disable = true\n        if (this._timer) {\n            clearTimeout(this._timer)\n            this._timer = null\n        }\n    }\n}\n\n// 二次贝塞尔曲线\nfunction bezier2(p0, p1, p2, t) {\n    const t2 = t * t\n    const m = 1 - t\n    const m2 = m * (1 - t)\n    return p0 * m2 + 2 * p1 * t * m + p2 * t2\n}\n\n// 三次贝塞尔曲线\nfunction bezier3(p0, p1, p2, p3, t) {\n    const t2 = t * t\n    const t3 = t * t2\n    const m = 1 - t\n    const m2 = m * (1 - t)\n    const m3 = m2 * (1 - t)\n    return p0 * m3 + 3 * p1 * t * m2 + 3 * p2 * t2 * m + p3 * t3\n}\n\nfunction getMidPoint(p0, p1) {\n    const x0 = p0[0]\n    const y0 = p0[1]\n    const x1 = p1[0]\n    const y1 = p1[1]\n    return [(x0 + x1) / 2, (y0 + y1) / 2]\n}\nfunction movePoint(p, v) {\n    const px = p[0]\n    const py = p[1]\n    const vx = v[0]\n    const vy = v[1]\n    return [px + vx, py + vy]\n}\nfunction getVector(p0, p1) {\n    const x0 = p0[0]\n    const y0 = p0[1]\n    const x1 = p1[0]\n    const y1 = p1[1]\n    return [x1 -x0, y1 - y0]\n}\n\n// 绘制过指定点的分段贝塞尔曲线\nfunction smoothLine(points, smooth = 50) {\n    const len = points.length\n    if (len < 3) {\n        return points\n    }\n    const newPoints = []\n    const controls = []\n    for (let i = 0; i < len - 2; i++) {\n        const p0 = points[i]\n        const p1 = points[i + 1]\n        const p2 = points[i + 2]\n        const m1 = getMidPoint(p0, p1)\n        const m2 = getMidPoint(p1, p2)\n        const m = getMidPoint(m1, m2)\n        const v = getVector(m, p1)\n        const _m1 = movePoint(m1, v)\n        const _m2 = movePoint(m2, v)\n        // 起点\n        if (i === 0) {\n            for(let j = 0; j < smooth; j++) {\n                const x = bezier2(p0[0], _m1[0], p1[0], j/smooth)\n                const y = bezier2(p0[1], _m1[1], p1[1], j/smooth)\n                newPoints.push([x, y])\n            }\n            controls.push(_m1)\n            controls.push(_m2)\n        } else {\n            for(let j = 0; j < smooth; j++) {\n                const prev = controls[controls.length - 1]\n                const x = bezier3(p0[0], prev[0], _m1[0], p1[0], j/smooth)\n                const y = bezier3(p0[1], prev[1], _m1[1], p1[1], j/smooth)\n                newPoints.push([x, y])\n            }\n            controls.push(_m1)\n            controls.push(_m2)\n            // 结束\n            if (i === len - 3) {\n                for(let j = 0; j <= smooth; j++) {\n                    const x = bezier2(p1[0], _m2[0], p2[0], j/smooth)\n                    const y = bezier2(p1[1], _m2[1], p2[1], j/smooth)\n                    newPoints.push([x, y])\n                }\n            }\n        }\n    }\n    return {\n        controls,\n        points: newPoints\n    }\n}\n\nvar lineData = smoothLine(data, smooth)\n\noption = {\n    animation: false,\n    title: {\n        text: '延指定路径移动的动画'\n    },\n    tooltip: {\n        show: false,\n        triggerOn: 'none',\n        formatter: function (params) {\n            return 'X: ' + params.data[0].toFixed(2) + '<br>Y: ' + params.data[1].toFixed(2);\n        }\n    },\n    grid: {\n    },\n    xAxis: {\n        min: -50,\n        max: 300,\n        type: 'value',\n        axisLine: {onZero: false}\n    },\n    yAxis: {\n        min: -50,\n        max: 300,\n        type: 'value',\n        axisLine: {onZero: false}\n    },\n    dataZoom: [\n        {\n            type: 'slider',\n            xAxisIndex: 0,\n            filterMode: 'empty'\n        },\n        {\n            type: 'slider',\n            yAxisIndex: 0,\n            filterMode: 'empty'\n        },\n        {\n            type: 'inside',\n            xAxisIndex: 0,\n            filterMode: 'empty'\n        },\n        {\n            type: 'inside',\n            yAxisIndex: 0,\n            filterMode: 'empty'\n        }\n    ],\n    series: [\n        {\n            id: 'a',\n            type: 'line',\n            smooth: true,\n            symbolSize: symbolSize,\n            lineStyle: {width: 0},\n            data: data\n        },\n        {\n            id: 'b',\n            type: 'line',\n            smooth: true,\n            symbolSize: 0,\n            lineStyle: { color: 'red' },\n            data: lineData.points\n        },\n        {\n            id: 'c',\n            type: 'scatter',\n            symbolSize: 5,\n            itemStyle: { color: 'black' },\n            data: showControl ? lineData.controls : []\n        },\n    ]\n};\n\n\nsetTimeout(function () {\n    // Add shadow circles (which is not visible) to enable drag.\n    myChart.setOption({\n        graphic: [...echarts.util.map(data, function (item, dataIndex) {\n            return {\n                type: 'circle',\n                position: myChart.convertToPixel('grid', item),\n                shape: {\n                    cx: 0,\n                    cy: 0,\n                    r: symbolSize / 2\n                },\n                invisible: true,\n                draggable: true,\n                ondrag: echarts.util.curry(onPointDragging, dataIndex),\n                onmousemove: echarts.util.curry(showTooltip, dataIndex),\n                onmouseout: echarts.util.curry(hideTooltip, dataIndex),\n                onclick: echarts.util.curry(removePoint, dataIndex),\n                z: 100\n            };\n        }), {\n            type: 'rect',\n            position: myChart.convertToPixel('grid', data[0]),\n            shape: {\n                x: -symbolSize/2,\n                y: -symbolSize/2,\n                width: symbolSize,\n                height: symbolSize\n            },\n            style: {\n                fill: 'green'\n            },\n            z: 200\n        }]\n    });\n    animate.start(lineData.points, easing, during, true)\n}, 0);\n\nwindow.addEventListener('resize', updatePosition);\n\nmyChart.on('dataZoom', updatePosition);\n\nfunction updatePosition() {\n    myChart.setOption({\n        graphic: echarts.util.map(data, function (item, dataIndex) {\n            return {\n                position: myChart.convertToPixel('grid', item)\n            };\n        })\n    });\n}\n\nfunction showTooltip(dataIndex) {\n    myChart.dispatchAction({\n        type: 'showTip',\n        seriesIndex: 0,\n        dataIndex: dataIndex\n    });\n}\n\nfunction hideTooltip(dataIndex) {\n    myChart.dispatchAction({\n        type: 'hideTip'\n    });\n}\n\nfunction onPointDragging(dataIndex, dx, dy) {\n    data[dataIndex] = myChart.convertFromPixel('grid', this.position);\n    \n    lineData = smoothLine(data, smooth)\n    animate.stop()\n    // Update data\n    myChart.setOption({\n        series: [{\n            id: 'a',\n            type: 'line',\n            smooth: true,\n            symbolSize: symbolSize,\n            lineStyle: {width: 0},\n            data: data\n        },\n        {\n            id: 'b',\n            type: 'line',\n            smooth: true,\n            symbolSize: 0,\n            \n            data: lineData.points\n        },\n        {\n            id: 'c',\n            type: 'scatter',\n            symbolSize: 5,\n            data: showControl ? lineData.controls : []\n        },]\n    })\n    animate.start(lineData.points, easing, during, true)\n}\n\nfunction removePoint(dataIndex) {\n    data = [...data.slice(0, dataIndex), ...data.slice(dataIndex+1)]\n    update()\n}\n\nvar zr = myChart.getZr();\nconsole.log(zr)\n\nfunction update() {\n    animate.stop()\n    lineData = smoothLine(data, smooth)\n    myChart.setOption({\n        series: [{\n            id: 'a',\n            type: 'line',\n            smooth: true,\n            symbolSize: symbolSize,\n            lineStyle: {width: 0},\n            data: data\n        },\n        {\n            id: 'b',\n            type: 'line',\n            smooth: true,\n            symbolSize: 0,\n            data: lineData.points\n        },\n        {\n            id: 'c',\n            type: 'scatter',\n            symbolSize: 5,\n            data: lineData.controls\n        },]\n    });\n    setTimeout(function () {\n        // Add shadow circles (which is not visible) to enable drag.\n        myChart.setOption({\n            graphic: [...echarts.util.map(data, function (item, dataIndex) {\n                return {\n                    type: 'circle',\n                    position: myChart.convertToPixel('grid', item),\n                    shape: {\n                        cx: 0,\n                        cy: 0,\n                        r: symbolSize / 2\n                    },\n                    invisible: true,\n                    draggable: true,\n                    ondrag: echarts.util.curry(onPointDragging, dataIndex),\n                    onmousemove: echarts.util.curry(showTooltip, dataIndex),\n                    onmouseout: echarts.util.curry(hideTooltip, dataIndex),\n                    onclick: echarts.util.curry(removePoint, dataIndex),\n                    z: 100\n                };\n            }), {\n                type: 'rect',\n                position: myChart.convertToPixel('grid', data[0]),\n                shape: {\n                    x: -symbolSize/2,\n                    y: -symbolSize/2,\n                    width: symbolSize,\n                    height: symbolSize\n                },\n                style: {\n                    fill: 'green'\n                },\n                z: 200\n            }]\n        });\n        animate.start(lineData.points, easing, during, true)\n    }, 0);\n}\n\nzr.on('click', function (params) {\n    if (params.target && params.target.type === 'circle') {\n        return\n    }\n    var pointInPixel = [params.offsetX, params.offsetY];\n    var pointInGrid = myChart.convertFromPixel('grid', pointInPixel);\n\n    if (myChart.containPixel('grid', pointInPixel)) {\n        data.push(pointInGrid);\n        data.sort((a, b) => a[0]-b[0])\n\n        update()\n    }\n});\n\nconsole.log(option)","html":"","externalScripts":"","updaterUID":"bd-1847551832","theme":"","layout":"","viewCount":312,"userName":"s***0","commentCount":0,"starCount":2,"isStared":0,"thumbnailURL":"https://www.makeapie.com/ecg-storage/ec_gallery_thumbnail/xrYkHMQpRS.png?v=1589794325209","isCustomThumbnail":0,"builtinTags":["category-work","dataZoom","graphic","grid","series-line","series-scatter","title","tooltip"],"customTags":[],"updaterUserName":"s***0"}}