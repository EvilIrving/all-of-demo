{"status":0,"data":{"cid":"xzwsDCo7bo","authorUid":"bd-405506747","authorUserName":"s***a","title":"上海社区养老组织热力图2021","description":"","latestVersion":4,"alwaysLatest":0,"createTime":"2021-07-10T07:08:48.000Z","lastUpdateTime":"2021-08-03T02:48:30.000Z","auth":2,"uid":"bd-405506747","publishedVersion":0,"forkFrom":"-","isSpam":0,"version":4,"parentVersion":3,"echartsVersion":"5.1.2","versionCreateTime":"2021-08-03T02:48:31.000Z","code":"var option = {\n    bmap: {\n        center: [121.4693, 31.2],\n        zoom: 10,\n        roam: true,\n        enableMapClick: false,\n        mapStyle: {\n            styleJson: [\n                {\n                    featureType: 'all',\n                    elementType: 'all',\n                    stylers: {\n                        lightness: 15,\n                        saturation: -50,\n                    },\n                },\n                {\n                    featureType: 'highway',\n                    elementType: 'geometry.fill',\n                    stylers: {\n                        color: '#ffffff',\n                    },\n                },\n                {\n                    featureType: 'poi',\n                    elementType: 'labels.icon',\n                    stylers: {\n                        visibility: 'off',\n                    },\n                },\n                {\n                    featureType: 'road',\n                    elementType: 'labels',\n                    stylers: {\n                        visibility: 'off',\n                    },\n                },\n            ],\n        },\n    },\n    title: {\n        x: 'center',\n        text: '上海社区养老组织热力图',\n        subtext: '',\n        textStyle: {\n            color: '#696969',\n            fontSize: 25,\n        },\n    },\n};\n\nmyChart.setOption(option);\n\nsetTimeout(init, 0);\n\nfunction init() {\n    initMap();\n    initMapv();\n}\n\nfunction getMap() {\n    return myChart.getModel().getComponent('bmap').getBMap();\n}\n\nfunction initMap() {\n    var top_left_navigation = new BMap.NavigationControl({\n        type: BMAP_NAVIGATION_CONTROL_SMALL,\n    });\n    var scale = new BMap.ScaleControl({\n        offset: new BMap.Size(100, 50),\n    });\n    var map = getMap();\n    map.addControl(top_left_navigation);\n    map.addControl(scale);\n    map.disableDoubleClickZoom();\n    return map;\n}\n\nfunction initMapv() {\n    var map = getMap();\n    var data = [];\n    var randomCount = points.length;\n\n    // 构造数据\n    while (randomCount--) {\n        var cityCenter = points[randomCount];\n        data.push({\n            geometry: {\n                type: 'Point',\n                coordinates: [cityCenter[0], cityCenter[1]],\n            },\n            count: cityCenter[2],\n        });\n    }\n\n    var dataSet = new mapv.DataSet(data);\n    //console.log(dataSet)\n\n    var options = {\n        fillStyle: '#DC143C',\n        strokeStyle: 'black', // 描边颜色\n        lineWidth: 1,\n        //shadowColor: 'white',\n        //shadowBlur: 1,\n        size: 15,\n        globalAlpha: 1,\n        gradient: { 0.25: 'rgb(0,0,255)', 0.5: 'rgb(0,255,0)', 0.75: 'yellow', 1.0: 'rgb(255,0,0)' },\n        label: {\n            show: true,\n            fillStyle: 'white',\n            average: false,\n            //shadowColor: 'black',\n            // font: '20px Arial',\n            //shadowBlur: 10,\n        },\n        max: 3,\n\n        draw: 'heatmap',\n        methods: {\n            // 一些事件回调函数\n            click: function (item) {\n                // 点击事件，返回对应点击元素的对象值\n                console.log(item);\n            },\n        },\n    };\n\n    var mapvLayer = new mapv.baiduMapLayer(map, dataSet, options);\n}\n\n//---------------------------------------------\n\nvar points = [\n\n[121.469876782248,31.273721070047,1],\n[121.418394355386,31.3133588508395,1],\n[121.435551001592,31.3331638901449,1],\n[121.603444252899,31.2637399744409,1],\n[121.4082002039,31.3554095254148,1],\n[121.381213258565,31.1968148054537,1],\n[121.547051017085,31.6848768942766,1],\n[121.506950209967,31.3957964177403,1],\n[121.353228595844,31.4213809943265,1],\n[121.334125501258,31.4786349363326,1],\n[121.472011425631,31.3370185112196,1],\n[121.486850907148,31.4074878733841,1],\n[121.462024244633,31.3421664706414,1],\n[121.83914412654,31.5323043494477,1],\n[121.396163113083,31.6257406126358,1],\n[121.848411585164,31.3462218738458,1],\n[121.494644682108,31.629976151533,1],\n[121.778591777537,31.5226195290328,1],\n[121.463925148922,31.6634600899975,1],\n[121.574845856175,30.8687550756141,1],\n[121.431713310199,30.7970595812757,1],\n[121.447202672633,30.9989135285422,1],\n[121.402277675672,30.9013332678464,1],\n[121.478999434024,31.2795290407276,1],\n[121.436839800508,31.1981679195382,1],\n[121.45757790185,31.2340192321385,1],\n[121.477838823305,31.2696724677033,1],\n[121.494884436255,31.2700104379951,1],\n[121.438597203187,31.2332038422688,1],\n[121.538872933553,31.1493744070405,1],\n[121.49872637304,31.2528239386035,1],\n[121.650466349463,30.9107608151123,1],\n[121.494601809579,31.2851591184254,1],\n[121.494601809579,31.2851591184254,1],\n[121.562638863447,31.1785229353569,1],\n[121.522229630319,31.2436606691494,1],\n[121.465034480769,30.9213199388172,1],\n[121.58186080475,30.9343657196239,1],\n[121.477782230058,31.2059297689316,1],\n[121.491786273975,31.2358144902528,1],\n[121.504246887094,31.300162317392,1],\n[121.498025618386,31.2092019222985,1],\n[121.193443473426,30.7910734817746,1],\n[121.47393544961,31.2358220979302,1],\n[121.47393544961,31.2358220979302,1],\n[121.485418006554,31.2434306577266,1],\n[121.504208940873,31.2322262554045,1],\n[121.471235469332,31.2233013872603,1],\n[121.180596716498,30.8994091451047,1],\n[121.48837546814,31.2069387354708,1],\n[121.507660410303,31.2256802515979,1],\n[121.500852195063,31.2290587280869,1],\n[121.253501574737,31.3850711747581,1],\n[121.417200307041,30.8006612645052,1],\n[121.348479349833,30.7409017252181,1],\n[121.324938599977,30.7317373586464,1],\n[121.198468324957,30.8061861005615,1],\n[121.457946954499,31.2506236817808,1],\n[121.378580082573,30.7732441036199,1],\n[121.319089999599,30.8873008463566,1],\n[121.319649531643,30.8872656426318,1],\n[121.304126569888,30.8072778329687,1],\n[121.4841865887,31.3071103454952,1],\n[121.459176029572,31.2837208859099,1],\n[121.445590643633,31.2343257646533,1],\n[121.450767319575,31.2416996227765,1],\n[121.451388487056,31.2327468756417,1],\n[121.448035741401,31.2286574910561,1],\n[121.465378786898,31.3183314925332,1],\n[121.452886231832,31.3194700210451,1],\n[121.446339650767,31.2906024110283,1],\n[121.471494089692,31.2501917939364,1],\n[121.465178716295,31.2436155028235,1],\n[121.374185340256,31.1342326465834,1],\n[121.316921045436,31.2195158003406,1],\n[121.4725849937,31.2548368445297,1],\n[121.38947099844,31.1572906243438,1],\n[121.389665098007,31.1750964921128,1],\n[121.405153690593,31.01617137005,1],\n[121.537086024232,31.0631098480045,1],\n[121.376119468374,31.1203169875427,1],\n[121.388768812786,31.0961616422284,1],\n[121.051392536692,31.0046648187979,1],\n[121.755912887141,30.9774403937783,1],\n[121.641542765781,31.322033620977,1],\n[121.618422326786,31.3033771681635,1],\n[121.586986279074,31.3510442518219,1],\n[121.59250796901,31.0204593098916,1],\n[121.758236923868,31.0544658639371,1],\n[121.606591597406,31.1267073888516,1],\n[121.849028271897,31.0410677402715,1],\n[121.516924904519,31.1962142479104,1],\n[121.813129585243,30.9169958810735,1],\n[121.633719840807,31.1983083185316,1],\n[121.879566423726,30.980637840397,1],\n[121.666135785321,31.2135691381637,1],\n[121.530528753332,31.2160875326289,1],\n[121.826416060922,30.9777199195254,1],\n[121.522177207006,31.2319240389101,1],\n[121.650675879223,31.0278955789002,1],\n[121.706043546585,31.0294313965473,1],\n[121.504257000218,31.179374873885,1],\n[121.464330194877,31.2677061674839,1],\n[121.442621976584,31.270929990217,1],\n[121.434214412824,31.2620876081042,1],\n[121.352863234332,31.2891189982229,1],\n[121.440564695271,31.250848772482,1],\n[121.398997602933,31.2347923930579,1],\n[121.392496433008,31.2584727823967,1],\n[121.126167583461,31.1980928489199,1],\n[121.235724378187,31.2062206414189,1],\n[121.625068683542,31.5485599932156,1],\n[121.356425913086,31.7210745946171,1],\n[120.92386010344,31.0426354909736,1],\n[121.276189250562,31.1756022413165,1],\n[121.203262056854,31.1578639862529,1],\n[121.18640574562,31.2084914103295,1],\n[121.066455323483,31.0814911740177,1],\n[121.534170006869,30.8377274555644,1],\n[121.347464959895,30.8631520658324,1],\n[121.273860441137,31.088183640434,1],\n[121.207634814042,31.0458228145207,1],\n[121.216451502962,30.9383673779042,1],\n[121.325741881832,31.0165830193468,1],\n[121.129473384568,30.9889316332928,1],\n[121.074236445811,30.9402699569996,1],\n[121.212398977315,31.0187378449706,1],\n[121.700598707584,31.183978992634,1],\n[121.402513515004,31.1785108234077,1],\n[121.445298874003,31.2149036995576,1],\n[121.463803608187,31.2145659882205,1],\n[121.456942514193,31.1748381356108,1],\n[121.431877291379,31.1799717669106,1],\n[121.524052022707,31.2718683988739,1],\n[121.527349531556,31.2913655466849,1],\n[121.526101585778,31.266983963465,1],\n[121.54838707226,31.2743313657549,1],\n[121.518212212247,31.2821463993738,1],\n[121.528355798117,31.3223568633638,1],\n[121.54179038551,31.3079297876422,1],\n[121.539475876211,31.2967671127292,1],\n[121.549364602028,31.2941524096132,1],\n[121.379243125463,31.2217764568648,1],\n[121.420723031861,31.2037325598615,1],\n[121.431444038631,31.2236732673273,1],\n[121.43961834928,31.2222629408271,1],\n[121.409828382636,31.2189619309826,1],\n[121.394519884136,31.2093669050482,1],\n[121.440010451551,31.2090510192176,1],\n[121.365690395624,31.2205029239869,1],\n[121.422396036043,31.2194698634332,1],\n[121.224330720251,31.2752946603853,1],\n[121.187414331606,31.4307448395091,1],\n[121.291490327263,31.4765995987119,1],\n[121.371655249312,31.2521376619119,1],\n[121.499039605883,31.2249538348759,1],\n[121.452965282717,31.1400515859375,1],\n[121.551586064842,31.2480236122499,1],\n[121.498617959243,31.181846684909,1],\n[121.460385016738,31.2039629005213,1],\n[121.256934269583,31.0117441895561,1],\n[121.295093022832,31.7496307345151,1],\n[121.581663896182,31.1200297902111,1],\n[121.689658960727,31.2626247284332,1],\n[121.330191263583,31.2598248869539,1],\n[121.621010840824,31.2744384256708,1],\n[121.416815559198,31.2688452352277,1],\n[121.420014178983,31.2296612053128,1],\n[121.434809899547,31.2641129829819,1],\n[121.448262652474,31.2653877339353,1],\n[121.440564695271,31.250848772482,1],\n[121.23934158678,30.9999183941088,1],\n[121.457675226964,31.2093335989581,1],\n[121.460382717076,31.1257647490899,1],\n[121.445620736868,31.180826009376,1],\n[121.440664336216,31.1398144429822,1],\n[113.558881651622,23.2998606949244,1],\n[121.769799730935,31.1245378730823,1],\n[121.380778537987,31.2438727043696,1],\n[121.343206722286,30.7319638528111,1],\n[121.352863234332,31.2891189982229,1],\n[121.421233898205,31.2425519780091,1],\n[121.441816608863,31.2445681421303,1],\n[121.410004839483,31.2674394387813,1],\n[121.414100993134,31.2602028726962,1],\n[121.426917307387,31.2475075153791,1],\n[121.43070430201,31.268186914502,1],\n[121.397362327583,31.2385189297993,1],\n[121.429452705519,31.2887959409089,1],\n[121.408467359958,31.2619644451283,1],\n[121.403599352569,31.2653093889399,1],\n[121.747474002163,31.0523773939089,1],\n[121.43269097651,31.4232414356542,1],\n[121.225376158322,31.7738289250939,1],\n[121.431567016656,31.2675755268894,1],\n[121.53695675807,31.2692926683349,1],\n[121.549870056979,31.2149917393287,1],\n[121.276189250562,31.1756022413165,1],\n[121.464330194877,31.2677061674839,1],\n[120.926222900254,31.0429910353838,1],\n[121.420117304456,30.8014761307708,1],\n[121.173289311089,30.9046968965318,1],\n[121.180994486177,30.8313525463332,1],\n[121.023337842971,30.8921337500141,1],\n[121.419440521085,31.6791664134338,1],\n[121.411154773841,30.8022183035782,1],\n[121.500003254136,31.279784424511,1],\n[121.160305072994,31.1656480664878,1],\n[121.053721114354,31.0159283556639,1],\n[121.518296870355,31.1307312314605,1],\n[121.461633861719,31.193104504312,1],\n[121.124362710725,31.1434746672674,1],\n[121.046774797218,31.0138914963003,1],\n[121.389861117252,31.1526222413411,1],\n[121.276098120163,31.2466431379876,1],\n[121.342796645821,31.8350127406893,1],\n[121.625068683542,31.5485599932156,1],\n[121.727796575052,31.5265291918447,1],\n[121.657819846028,31.5869215875581,1],\n[121.415497985761,31.6276488982498,1],\n[121.541856316643,31.6237584337351,1],\n[121.857767711932,30.8623571358405,1],\n[121.694537851088,31.3932797943169,1],\n[121.112026397038,31.1674187739841,1],\n[121.507171258699,31.2770354649283,1],\n[121.478999434024,31.2795290407276,1],\n[121.108364330661,31.2632601299497,1],\n[121.144664406268,31.2481862366757,1],\n[121.358299622973,31.1736101714907,1],\n[121.49872637304,31.2528239386035,1],\n[121.414859925645,31.0484942188142,1],\n[121.252309792817,31.3877986482721,1],\n[121.470161620552,31.0499687945684,1],\n[121.523046137925,31.0814717670761,1],\n[121.379664073222,31.0383065448668,1],\n[121.476083714,31.2946064431643,1],\n[121.453293888263,30.9347657465508,1],\n[121.501723958341,30.9609738471784,1],\n[121.508052161336,30.9948212975715,1],\n[121.465387875954,30.9075689052954,1],\n[121.729741923905,30.944572571737,1],\n[121.729741923905,30.944572571737,1],\n[121.589198253986,30.9371950696902,1],\n[121.378580082573,30.7732441036199,1],\n[121.734339879997,31.2223810672181,1],\n[121.425269819573,31.0984150767787,1],\n[121.554661910518,31.2979357156569,1],\n\n];\n\n//---------------------------------------------\n\nvar mapv = {};\n(function (global, factory) {\n    // console.log(global,factory)\n    // typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    //     typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    //     (factory((global.mapv = global.mapv || {})));\n    factory(mapv);\n})(window, function (exports) {\n    'use strict';\n\n    var version = '2.0.13';\n\n    /**\n     * @author kyle / http://nikai.us/\n     */\n\n    var clear = function (context) {\n        context && context.clearRect && context.clearRect(0, 0, context.canvas.width, context.canvas.height);\n        //context.canvas.width = context.canvas.width;\n        //context.canvas.height = context.canvas.height;\n    };\n\n    /**\n     * @author kyle / http://nikai.us/\n     */\n\n    var resolutionScale$1 = function (context) {\n        var devicePixelRatio = window.devicePixelRatio;\n        context.canvas.width = context.canvas.width * devicePixelRatio;\n        context.canvas.height = context.canvas.height * devicePixelRatio;\n        context.canvas.style.width = context.canvas.width / devicePixelRatio + 'px';\n        context.canvas.style.height = context.canvas.height / devicePixelRatio + 'px';\n        context.scale(devicePixelRatio, devicePixelRatio);\n    };\n\n    function Event() {\n        this._subscribers = {}; // event subscribers\n    }\n\n    /**\n     * Subscribe to an event, add an event listener\n     * @param {String} event        Event name. Available events: 'put', 'update',\n     *                              'remove'\n     * @param {function} callback   Callback method. Called with three parameters:\n     *                                  {String} event\n     *                                  {Object | null} params\n     *                                  {String | Number} senderId\n     */\n    Event.prototype.on = function (event, callback) {\n        var subscribers = this._subscribers[event];\n        if (!subscribers) {\n            subscribers = [];\n            this._subscribers[event] = subscribers;\n        }\n\n        subscribers.push({\n            callback: callback,\n        });\n    };\n\n    /**\n     * Unsubscribe from an event, remove an event listener\n     * @param {String} event\n     * @param {function} callback\n     */\n    Event.prototype.off = function (event, callback) {\n        var subscribers = this._subscribers[event];\n        if (subscribers) {\n            //this._subscribers[event] = subscribers.filter(listener => listener.callback != callback);\n            for (var i = 0; i < subscribers.length; i++) {\n                if (subscribers[i].callback == callback) {\n                    subscribers.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    };\n\n    /**\n     * Trigger an event\n     * @param {String} event\n     * @param {Object | null} params\n     * @param {String} [senderId]       Optional id of the sender.\n     * @private\n     */\n    Event.prototype._trigger = function (event, params, senderId) {\n        if (event == '*') {\n            throw new Error('Cannot trigger event *');\n        }\n\n        var subscribers = [];\n        if (event in this._subscribers) {\n            subscribers = subscribers.concat(this._subscribers[event]);\n        }\n        if ('*' in this._subscribers) {\n            subscribers = subscribers.concat(this._subscribers['*']);\n        }\n\n        for (var i = 0, len = subscribers.length; i < len; i++) {\n            var subscriber = subscribers[i];\n            if (subscriber.callback) {\n                subscriber.callback(event, params, senderId || null);\n            }\n        }\n    };\n\n    var classCallCheck = function (instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError('Cannot call a class as a function');\n        }\n    };\n\n    var createClass = (function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if ('value' in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    })();\n\n    var get = function get(object, property, receiver) {\n        if (object === null) object = Function.prototype;\n        var desc = Object.getOwnPropertyDescriptor(object, property);\n\n        if (desc === undefined) {\n            var parent = Object.getPrototypeOf(object);\n\n            if (parent === null) {\n                return undefined;\n            } else {\n                return get(parent, property, receiver);\n            }\n        } else if ('value' in desc) {\n            return desc.value;\n        } else {\n            var getter = desc.get;\n\n            if (getter === undefined) {\n                return undefined;\n            }\n\n            return getter.call(receiver);\n        }\n    };\n\n    var inherits = function (subClass, superClass) {\n        if (typeof superClass !== 'function' && superClass !== null) {\n            throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                enumerable: false,\n                writable: true,\n                configurable: true,\n            },\n        });\n        if (superClass)\n            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);\n    };\n\n    var possibleConstructorReturn = function (self, call) {\n        if (!self) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === 'object' || typeof call === 'function') ? call : self;\n    };\n\n    /**\n     * @author kyle / http://nikai.us/\n     */\n\n    /**\n     * DataSet\n     *\n     * A data set can:\n     * - add/remove/update data\n     * - gives triggers upon changes in the data\n     * - can  import/export data in various data formats\n     * @param {Array} [data]    Optional array with initial data\n     * the field geometry is like geojson, it can be:\n     * {\n     *     \"type\": \"Point\",\n     *     \"coordinates\": [125.6, 10.1]\n     * }\n     * {\n     *     \"type\": \"LineString\",\n     *     \"coordinates\": [\n     *         [102.0, 0.0], [103.0, 1.0], [104.0, 0.0], [105.0, 1.0]\n     *     ]\n     * }\n     * {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [\n     *         [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],\n     *           [100.0, 1.0], [100.0, 0.0] ]\n     *     ]\n     * }\n     * @param {Object} [options]   Available options:\n     *\n     */\n    function DataSet(data, options) {\n        this._options = options || {};\n        this._data = []; // map with data indexed by id\n\n        // add initial data when provided\n        if (data) {\n            this.add(data);\n        }\n    }\n\n    DataSet.prototype = new Event();\n\n    /**\n     * Add data.\n     */\n    DataSet.prototype.add = function (data, senderId) {\n        if (Array.isArray(data)) {\n            // Array\n            for (var i = 0, len = data.length; i < len; i++) {\n                if (data[i].time && data[i].time.length == 14 && data[i].time.substr(0, 2) == '20') {\n                    var time = data[i].time;\n                    data[i].time = new Date(\n                        time.substr(0, 4) +\n                            '-' +\n                            time.substr(4, 2) +\n                            '-' +\n                            time.substr(6, 2) +\n                            ' ' +\n                            time.substr(8, 2) +\n                            ':' +\n                            time.substr(10, 2) +\n                            ':' +\n                            time.substr(12, 2)\n                    ).getTime();\n                }\n                this._data.push(data[i]);\n            }\n        } else if (data instanceof Object) {\n            // Single item\n            this._data.push(data);\n        } else {\n            throw new Error('Unknown dataType');\n        }\n    };\n\n    /**\n     * get data.\n     */\n    DataSet.prototype.get = function (args) {\n        args = args || {};\n\n        //console.time('copy data time')\n        var start = new Date();\n        // TODO: 不修改原始数据，在数据上挂载新的名称，每次修改数据直接修改新名称下的数据，可以省去deepCopy\n        // var data = deepCopy(this._data);\n        var data = this._data;\n\n        // console.timeEnd('copy data time')\n\n        // console.time('transferCoordinate time')\n\n        var start = new Date();\n\n        if (args.filter) {\n            var newData = [];\n            for (var i = 0; i < data.length; i++) {\n                if (args.filter(data[i])) {\n                    newData.push(data[i]);\n                }\n            }\n            data = newData;\n        }\n\n        if (args.transferCoordinate) {\n            data = this.transferCoordinate(data, args.transferCoordinate, args.fromColumn, args.toColumn);\n        }\n\n        // console.timeEnd('transferCoordinate time')\n\n        return data;\n    };\n\n    /**\n     * set data.\n     */\n    DataSet.prototype.set = function (data) {\n        this._set(data);\n        this._trigger('change');\n    };\n\n    /**\n     * set data.\n     */\n    DataSet.prototype._set = function (data) {\n        this.clear();\n        this.add(data);\n    };\n\n    /**\n     * clear data.\n     */\n    DataSet.prototype.clear = function (args) {\n        this._data = []; // map with data indexed by id\n    };\n\n    /**\n     * remove data.\n     */\n    DataSet.prototype.remove = function (args) {};\n\n    /**\n     * update data.\n     */\n    DataSet.prototype.update = function (args) {};\n\n    /**\n     * transfer coordinate.\n     */\n    DataSet.prototype.transferCoordinate = function (data, transferFn, fromColumn, toColumnName) {\n        toColumnName = toColumnName || '_coordinates';\n        fromColumn = fromColumn || 'coordinates';\n\n        for (var i = 0; i < data.length; i++) {\n            var geometry = data[i].geometry;\n            var coordinates = geometry[fromColumn];\n            switch (geometry.type) {\n                case 'Point':\n                    geometry[toColumnName] = transferFn(coordinates);\n                    break;\n                case 'LineString':\n                    var newCoordinates = [];\n                    for (var j = 0; j < coordinates.length; j++) {\n                        newCoordinates.push(transferFn(coordinates[j]));\n                    }\n                    geometry[toColumnName] = newCoordinates;\n                    break;\n                case 'Polygon':\n                    var newCoordinates = getPolygon(coordinates);\n                    geometry[toColumnName] = newCoordinates;\n                    break;\n                case 'MultiPolygon':\n                    var newCoordinates = [];\n                    for (var c = 0; c < coordinates.length; c++) {\n                        var polygon = coordinates[c];\n                        var polygon = getPolygon(polygon);\n                        newCoordinates.push(polygon);\n                    }\n\n                    geometry[toColumnName] = newCoordinates;\n                    break;\n            }\n        }\n\n        function getPolygon(coordinates) {\n            var newCoordinates = [];\n            for (var c = 0; c < coordinates.length; c++) {\n                var coordinate = coordinates[c];\n                var newcoordinate = [];\n                for (var j = 0; j < coordinate.length; j++) {\n                    newcoordinate.push(transferFn(coordinate[j]));\n                }\n                newCoordinates.push(newcoordinate);\n            }\n            return newCoordinates;\n        }\n\n        return data;\n    };\n\n    DataSet.prototype.initGeometry = function (transferFn) {\n        if (transferFn) {\n            this._data.forEach(function (item) {\n                item.geometry = transferFn(item);\n            });\n        } else {\n            this._data.forEach(function (item) {\n                if (!item.geometry && item.lng && item.lat) {\n                    item.geometry = {\n                        type: 'Point',\n                        coordinates: [item.lng, item.lat],\n                    };\n                }\n            });\n        }\n    };\n\n    /**\n     * 获取当前列的最大值\n     */\n    DataSet.prototype.getMax = function (columnName) {\n        var data = this._data;\n\n        if (!data || data.length <= 0) {\n            return;\n        }\n\n        var max = parseFloat(data[0][columnName]);\n\n        for (var i = 1; i < data.length; i++) {\n            var value = parseFloat(data[i][columnName]);\n            if (value > max) {\n                max = value;\n            }\n        }\n\n        return max;\n    };\n\n    /**\n     * 获取当前列的总和\n     */\n    DataSet.prototype.getSum = function (columnName) {\n        var data = this._data;\n\n        if (!data || data.length <= 0) {\n            return;\n        }\n\n        var sum = 0;\n\n        for (var i = 0; i < data.length; i++) {\n            if (data[i][columnName]) {\n                sum += parseFloat(data[i][columnName]);\n            }\n        }\n\n        return sum;\n    };\n\n    /**\n     * 获取当前列的最小值\n     */\n    DataSet.prototype.getMin = function (columnName) {\n        var data = this._data;\n\n        if (!data || data.length <= 0) {\n            return;\n        }\n\n        var min = parseFloat(data[0][columnName]);\n\n        for (var i = 1; i < data.length; i++) {\n            var value = parseFloat(data[i][columnName]);\n            if (value < min) {\n                min = value;\n            }\n        }\n\n        return min;\n    };\n\n    /**\n     * @author kyle / http://nikai.us/\n     */\n\n    var pathSimple = {\n        drawDataSet: function drawDataSet(context, dataSet, options) {\n            var data = dataSet instanceof DataSet ? dataSet.get() : dataSet;\n\n            for (var i = 0, len = data.length; i < len; i++) {\n                var item = data[i];\n                this.draw(context, item, options);\n            }\n        },\n        draw: function draw(context, data, options) {\n            var type = data.geometry.type;\n            var coordinates = data.geometry._coordinates || data.geometry.coordinates;\n            var symbol = options.symbol || 'circle';\n            switch (type) {\n                case 'Point':\n                    var size = data._size || data.size || options._size || options.size || 5;\n                    if (options.symbol === 'rect') {\n                        context.rect(coordinates[0] - size / 2, coordinates[1] - size / 2, size, size);\n                    } else {\n                        if (options.bigData === 'Point') {\n                            context.moveTo(coordinates[0], coordinates[1]);\n                        }\n                        context.arc(coordinates[0], coordinates[1], size, 0, Math.PI * 2);\n                    }\n                    break;\n                case 'LineString':\n                    for (var j = 0; j < coordinates.length; j++) {\n                        var x = coordinates[j][0];\n                        var y = coordinates[j][1];\n                        if (j == 0) {\n                            context.moveTo(x, y);\n                        } else {\n                            context.lineTo(x, y);\n                        }\n                    }\n                    break;\n                case 'Polygon':\n                    this.drawPolygon(context, coordinates);\n                    break;\n                case 'MultiPolygon':\n                    for (var i = 0; i < coordinates.length; i++) {\n                        var polygon = coordinates[i];\n                        this.drawPolygon(context, polygon);\n                    }\n                    context.closePath();\n                    break;\n                default:\n                    console.log('type' + type + 'is not support now!');\n                    break;\n            }\n        },\n\n        drawPolygon: function drawPolygon(context, coordinates) {\n            for (var i = 0; i < coordinates.length; i++) {\n                var coordinate = coordinates[i];\n\n                context.moveTo(coordinate[0][0], coordinate[0][1]);\n                for (var j = 1; j < coordinate.length; j++) {\n                    context.lineTo(coordinate[j][0], coordinate[j][1]);\n                }\n                context.lineTo(coordinate[0][0], coordinate[0][1]);\n            }\n        },\n    };\n\n    /**\n     * @author kyle / http://nikai.us/\n     */\n\n    var drawSimple = {\n        draw: function draw(context, dataSet, options) {\n            var data = dataSet instanceof DataSet ? dataSet.get() : dataSet;\n\n            // console.log('xxxx',options)\n            context.save();\n\n            for (var key in options) {\n                context[key] = options[key];\n            }\n\n            // console.log(data);\n            if (options.bigData) {\n                context.save();\n                context.beginPath();\n\n                for (var i = 0, len = data.length; i < len; i++) {\n                    var item = data[i];\n\n                    pathSimple.draw(context, item, options);\n                }\n\n                var type = options.bigData;\n\n                if (type == 'Point' || type == 'Polygon' || type == 'MultiPolygon') {\n                    context.fill();\n\n                    if ((item.strokeStyle || options.strokeStyle) && options.lineWidth) {\n                        context.stroke();\n                    }\n                } else if (type == 'LineString') {\n                    context.stroke();\n                }\n\n                context.restore();\n            } else {\n                for (var i = 0, len = data.length; i < len; i++) {\n                    var item = data[i];\n\n                    context.save();\n\n                    if (item.fillStyle) {\n                        context.fillStyle = item.fillStyle;\n                    }\n\n                    if (item.strokeStyle) {\n                        context.strokeStyle = item.strokeStyle;\n                    }\n\n                    var type = item.geometry.type;\n\n                    context.beginPath();\n\n                    pathSimple.draw(context, item, options);\n\n                    if (type == 'Point' || type == 'Polygon' || type == 'MultiPolygon') {\n                        context.fill();\n\n                        if ((item.strokeStyle || options.strokeStyle) && options.lineWidth) {\n                            context.stroke();\n                        }\n                    } else if (type == 'LineString') {\n                        context.stroke();\n                    }\n\n                    context.restore();\n                }\n            }\n\n            context.restore();\n        },\n    };\n\n    function Canvas(width, height) {\n        var canvas;\n\n        if (typeof document === 'undefined') {\n            var Canvas = require('canvas');\n            canvas = new Canvas(width, height);\n        } else {\n            var canvas = document.createElement('canvas');\n\n            if (width) {\n                canvas.width = width;\n            }\n\n            if (height) {\n                canvas.height = height;\n            }\n        }\n\n        return canvas;\n    }\n\n    /**\n     * @author kyle / http://nikai.us/\n     */\n\n    /**\n     * Category\n     * @param {Object} [options]   Available options:\n     *                             {Object} gradient: { 0.25: \"rgb(0,0,255)\", 0.55: \"rgb(0,255,0)\", 0.85: \"yellow\", 1.0: \"rgb(255,0,0)\"}\n     */\n    function Intensity(options) {\n        options = options || {};\n        this.gradient = options.gradient || {\n            0.25: 'rgba(0, 0, 255, 1)',\n            0.55: 'rgba(0, 255, 0, 1)',\n            0.85: 'rgba(255, 255, 0, 1)',\n            1.0: 'rgba(255, 0, 0, 1)',\n        };\n        this.maxSize = options.maxSize || 35;\n        this.minSize = options.minSize || 0;\n        this.max = options.max || 100;\n        this.min = options.min || 0;\n        this.initPalette();\n    }\n\n    Intensity.prototype.setMax = function (value) {\n        this.max = value || 100;\n    };\n\n    Intensity.prototype.setMin = function (value) {\n        this.min = value || 0;\n    };\n\n    Intensity.prototype.setMaxSize = function (maxSize) {\n        this.maxSize = maxSize || 35;\n    };\n\n    Intensity.prototype.setMinSize = function (minSize) {\n        this.minSize = minSize || 0;\n    };\n\n    Intensity.prototype.initPalette = function () {\n        var gradient = this.gradient;\n\n        var canvas = new Canvas(256, 1);\n\n        var paletteCtx = (this.paletteCtx = canvas.getContext('2d'));\n\n        var lineGradient = paletteCtx.createLinearGradient(0, 0, 256, 1);\n\n        for (var key in gradient) {\n            lineGradient.addColorStop(parseFloat(key), gradient[key]);\n        }\n\n        paletteCtx.fillStyle = lineGradient;\n        paletteCtx.fillRect(0, 0, 256, 1);\n    };\n\n    Intensity.prototype.getColor = function (value) {\n        var imageData = this.getImageData(value);\n\n        return 'rgba(' + imageData[0] + ', ' + imageData[1] + ', ' + imageData[2] + ', ' + imageData[3] / 256 + ')';\n    };\n\n    Intensity.prototype.getImageData = function (value) {\n        var imageData = this.paletteCtx.getImageData(0, 0, 256, 1).data;\n\n        if (value === undefined) {\n            return imageData;\n        }\n\n        var max = this.max;\n        var min = this.min;\n\n        if (value > max) {\n            value = max;\n        }\n\n        if (value < min) {\n            value = min;\n        }\n\n        var index = Math.floor(((value - min) / (max - min)) * (256 - 1)) * 4;\n\n        return [imageData[index], imageData[index + 1], imageData[index + 2], imageData[index + 3]];\n    };\n\n    /**\n     * @param Number value\n     * @param Number max of value\n     * @param Number max of size\n     * @param Object other options\n     */\n    Intensity.prototype.getSize = function (value) {\n        var size = 0;\n        var max = this.max;\n        var min = this.min;\n        var maxSize = this.maxSize;\n        var minSize = this.minSize;\n\n        if (value > max) {\n            value = max;\n        }\n\n        if (value < min) {\n            value = min;\n        }\n\n        size = minSize + ((value - min) / (max - min)) * (maxSize - minSize);\n\n        return size;\n    };\n\n    Intensity.prototype.getLegend = function (options) {\n        var gradient = this.gradient;\n\n        var width = options.width || 20;\n        var height = options.height || 180;\n\n        var canvas = new Canvas(width, height);\n\n        var paletteCtx = canvas.getContext('2d');\n\n        var lineGradient = paletteCtx.createLinearGradient(0, height, 0, 0);\n\n        for (var key in gradient) {\n            lineGradient.addColorStop(parseFloat(key), gradient[key]);\n        }\n\n        paletteCtx.fillStyle = lineGradient;\n        paletteCtx.fillRect(0, 0, width, height);\n\n        return canvas;\n    };\n\n    var global$1 = typeof window === 'undefined' ? {} : window;\n\n    var devicePixelRatio = global$1.devicePixelRatio;\n\n    /**\n     * @author kyle / http://nikai.us/\n     */\n\n    function createCircle(size) {\n        var shadowBlur = size / 2;\n        var r2 = size + shadowBlur;\n        var offsetDistance = 10000;\n\n        var circle = new Canvas(r2 * 2, r2 * 2);\n        var context = circle.getContext('2d');\n\n        context.shadowBlur = shadowBlur;\n        context.shadowColor = 'black';\n        context.shadowOffsetX = context.shadowOffsetY = offsetDistance;\n\n        context.beginPath();\n        context.arc(r2 - offsetDistance, r2 - offsetDistance, size, 0, Math.PI * 2, true);\n        context.closePath();\n        context.fill();\n        return circle;\n    }\n\n    function colorize(pixels, gradient, options) {\n        var maxOpacity = options.maxOpacity || 0.8;\n        for (var i = 3, len = pixels.length, j; i < len; i += 4) {\n            j = pixels[i] * 4; // get gradient color from opacity value\n\n            if (pixels[i] / 256 > maxOpacity) {\n                pixels[i] = 256 * maxOpacity;\n            }\n\n            pixels[i - 3] = gradient[j];\n            pixels[i - 2] = gradient[j + 1];\n            pixels[i - 1] = gradient[j + 2];\n        }\n    }\n\n    function drawGray(context, dataSet, options) {\n        var max = options.max || 100;\n        var min = options.min || 0;\n        // console.log(max)\n        var size = options._size;\n        if (size == undefined) {\n            size = options.size;\n            if (size == undefined) {\n                size = 13;\n            }\n        }\n\n        var intensity = new Intensity({\n            gradient: options.gradient,\n            max: max,\n            min: min,\n        });\n\n        var circle = createCircle(size);\n        var circleHalfWidth = circle.width / 2;\n        var circleHalfHeight = circle.height / 2;\n\n        var data = dataSet;\n\n        var dataOrderByAlpha = {};\n\n        data.forEach(function (item, index) {\n            var count = item.count === undefined ? 1 : item.count;\n            var alpha = Math.min(1, count / max).toFixed(2);\n            dataOrderByAlpha[alpha] = dataOrderByAlpha[alpha] || [];\n            dataOrderByAlpha[alpha].push(item);\n        });\n\n        for (var i in dataOrderByAlpha) {\n            if (isNaN(i)) continue;\n            var _data = dataOrderByAlpha[i];\n            context.beginPath();\n            if (!options.withoutAlpha) {\n                context.globalAlpha = i;\n            }\n            context.strokeStyle = intensity.getColor(i * max);\n            _data.forEach(function (item, index) {\n                if (!item.geometry) {\n                    return;\n                }\n\n                var coordinates = item.geometry._coordinates || item.geometry.coordinates;\n                var type = item.geometry.type;\n                if (type === 'Point') {\n                    var count = item.count === undefined ? 1 : item.count;\n                    context.globalAlpha = count / max;\n                    context.drawImage(circle, coordinates[0] - circleHalfWidth, coordinates[1] - circleHalfHeight);\n                } else if (type === 'LineString') {\n                    var count = item.count === undefined ? 1 : item.count;\n                    context.globalAlpha = count / max;\n                    context.beginPath();\n                    pathSimple.draw(context, item, options);\n                    context.stroke();\n                } else if (type === 'Polygon') {\n                }\n            });\n        }\n    }\n\n    function draw(context, dataSet, options) {\n        var strength = options.strength || 0.3;\n        context.strokeStyle = 'rgba(0,0,0,' + strength + ')';\n        var shadowCanvas = new Canvas(context.canvas.width, context.canvas.height);\n        var shadowContext = shadowCanvas.getContext('2d');\n        shadowContext.scale(devicePixelRatio, devicePixelRatio);\n\n        options = options || {};\n\n        var data = dataSet instanceof DataSet ? dataSet.get() : dataSet;\n\n        context.save();\n\n        var intensity = new Intensity({\n            gradient: options.gradient,\n        });\n\n        //console.time('drawGray')\n        drawGray(shadowContext, data, options);\n\n        //console.timeEnd('drawGray');\n        // return false;\n        if (!options.absolute) {\n            //console.time('changeColor');\n            var colored = shadowContext.getImageData(0, 0, context.canvas.width, context.canvas.height);\n            colorize(colored.data, intensity.getImageData(), options);\n            //console.timeEnd('changeColor');\n            context.putImageData(colored, 0, 0);\n\n            context.restore();\n        }\n\n        intensity = null;\n        shadowCanvas = null;\n    }\n\n    var drawHeatmap = {\n        draw: draw,\n    };\n\n    /**\n     * @author kyle / http://nikai.us/\n     */\n\n    var drawGrid = {\n        draw: function draw(context, dataSet, options) {\n            context.save();\n\n            var data = dataSet instanceof DataSet ? dataSet.get() : dataSet;\n\n            var grids = {};\n            var gridIndexData = {};\n            var size = options._size || options.size || 50;\n\n            var offset = options.offset || {\n                x: 0,\n                y: 0,\n            };\n\n            for (var i = 0; i < data.length; i++) {\n                var coordinates = data[i].geometry._coordinates || data[i].geometry.coordinates;\n                var gridKey =\n                    Math.floor((coordinates[0] - offset.x) / size) +\n                    ',' +\n                    Math.floor((coordinates[1] - offset.y) / size);\n\n                if (!grids[gridKey]) {\n                    grids[gridKey] = 0;\n                    gridIndexData[gridKey] = [];\n                }\n                var count = ~~(data[i].count || 1);\n                grids[gridKey] += count;\n                gridIndexData[gridKey].push(data[i]);\n            }\n\n            for (var gridKey in grids) {\n                var total = grids[gridKey];\n                gridIndexData[gridKey].forEach((i) => {\n                    i.total = total;\n                    i.average = parseInt(total / gridIndexData[gridKey].length);\n                });\n            }\n\n            var intensity = new Intensity({\n                max: options.max || 100,\n                gradient: options.gradient,\n            });\n\n            for (var gridKey in grids) {\n                gridKey = gridKey.split(',');\n\n                context.beginPath();\n                context.rect(gridKey[0] * size + 0.5 + offset.x, gridKey[1] * size + 0.5 + offset.y, size, size);\n                var text = grids[gridKey];\n                if (options.label.average) {\n                    text = parseInt(grids[gridKey] / gridIndexData[gridKey].length);\n                }\n\n                context.fillStyle = intensity.getColor(text);\n                context.fill();\n                if (options.strokeStyle && options.lineWidth) {\n                    context.stroke();\n                }\n            }\n\n            if (options.label && options.label.show !== false) {\n                context.fillStyle = options.label.fillStyle || 'white';\n\n                if (options.label.font) {\n                    context.font = options.label.font;\n                }\n\n                if (options.label.shadowColor) {\n                    context.shadowColor = options.label.shadowColor;\n                }\n\n                if (options.label.shadowBlur) {\n                    context.shadowBlur = options.label.shadowBlur;\n                }\n\n                for (var gridKey in grids) {\n                    gridKey = gridKey.split(',');\n                    var text = grids[gridKey];\n                    if (options.label.average) {\n                        text = parseInt(text / gridIndexData[gridKey].length);\n                    }\n\n                    var textWidth = context.measureText(text).width;\n                    context.fillText(\n                        text,\n                        gridKey[0] * size + 0.5 + offset.x + size / 2 - textWidth / 2,\n                        gridKey[1] * size + 0.5 + offset.y + size / 2 + 5\n                    );\n                }\n            }\n\n            context.restore();\n        },\n    };\n\n    /**\n     * @author kyle / http://nikai.us/\n     */\n\n    function hex_corner(center, size, i) {\n        var angle_deg = 60 * i + 30;\n        var angle_rad = (Math.PI / 180) * angle_deg;\n        return [center.x + size * Math.cos(angle_rad), center.y + size * Math.sin(angle_rad)];\n    }\n\n    var drawHoneycomb = {\n        draw: function draw(context, dataSet, options) {\n            context.save();\n\n            var data = dataSet instanceof DataSet ? dataSet.get() : dataSet;\n\n            for (var key in options) {\n                context[key] = options[key];\n            }\n\n            var grids = {};\n\n            var offset = options.offset || {\n                x: 10,\n                y: 10,\n            };\n\n            //\n            var r = options._size || options.size || 40;\n            r = r / 2 / Math.sin(Math.PI / 3);\n            var dx = r * 2 * Math.sin(Math.PI / 3);\n            var dy = r * 1.5;\n\n            var binsById = {};\n\n            for (var i = 0; i < data.length; i++) {\n                var coordinates = data[i].geometry._coordinates || data[i].geometry.coordinates;\n                var py = (coordinates[1] - offset.y) / dy,\n                    pj = Math.round(py),\n                    px = (coordinates[0] - offset.x) / dx - (pj & 1 ? 0.5 : 0),\n                    pi = Math.round(px),\n                    py1 = py - pj;\n\n                if (Math.abs(py1) * 3 > 1) {\n                    var px1 = px - pi,\n                        pi2 = pi + (px < pi ? -1 : 1) / 2,\n                        pj2 = pj + (py < pj ? -1 : 1),\n                        px2 = px - pi2,\n                        py2 = py - pj2;\n                    if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) (pi = pi2 + (pj & 1 ? 1 : -1) / 2), (pj = pj2);\n                }\n\n                var id = pi + '-' + pj,\n                    bin = binsById[id];\n                if (bin) {\n                    bin.push(data[i]);\n                } else {\n                    bin = binsById[id] = [data[i]];\n                    bin.i = pi;\n                    bin.j = pj;\n                    bin.x = (pi + (pj & 1 ? 1 / 2 : 0)) * dx;\n                    bin.y = pj * dy;\n                }\n            }\n\n            var intensity = new Intensity({\n                max: options.max || 100,\n                maxSize: r,\n                gradient: options.gradient,\n            });\n\n            for (var key in binsById) {\n                var item = binsById[key];\n\n                context.beginPath();\n\n                for (var j = 0; j < 6; j++) {\n                    var radius = r;\n\n                    var result = hex_corner(\n                        {\n                            x: item.x + offset.x,\n                            y: item.y + offset.y,\n                        },\n                        radius,\n                        j\n                    );\n                    context.lineTo(result[0], result[1]);\n                }\n                context.closePath();\n\n                var count = 0;\n                for (var i = 0; i < item.length; i++) {\n                    count += item[i].count || 1;\n                }\n                item.count = count;\n\n                context.fillStyle = intensity.getColor(count);\n                context.fill();\n                if (options.strokeStyle && options.lineWidth) {\n                    context.stroke();\n                }\n            }\n\n            if (options.label && options.label.show !== false) {\n                context.fillStyle = options.label.fillStyle || 'white';\n\n                if (options.label.font) {\n                    context.font = options.label.font;\n                }\n\n                if (options.label.shadowColor) {\n                    context.shadowColor = options.label.shadowColor;\n                }\n\n                if (options.label.shadowBlur) {\n                    context.shadowBlur = options.label.shadowBlur;\n                }\n\n                for (var key in binsById) {\n                    var item = binsById[key];\n                    var text = item.count;\n                    if (text < 0) {\n                        text = text.toFixed(2);\n                    } else {\n                        text = ~~text;\n                    }\n                    var textWidth = context.measureText(text).width;\n                    context.fillText(text, item.x + offset.x - textWidth / 2, item.y + offset.y + 5);\n                }\n            }\n\n            context.restore();\n        },\n    };\n\n    function createShader(gl, src, type) {\n        var shader = gl.createShader(type);\n        gl.shaderSource(shader, src);\n        gl.compileShader(shader);\n        return shader;\n    }\n\n    function initShaders(gl, vs_source, fs_source) {\n        var vertexShader = createShader(gl, vs_source, gl.VERTEX_SHADER);\n        var fragmentShader = createShader(gl, fs_source, gl.FRAGMENT_SHADER);\n\n        var glProgram = gl.createProgram();\n\n        gl.attachShader(glProgram, vertexShader);\n        gl.attachShader(glProgram, fragmentShader);\n        gl.linkProgram(glProgram);\n\n        gl.useProgram(glProgram);\n\n        return glProgram;\n    }\n\n    function getColorData(color) {\n        var tmpCanvas = document.createElement('canvas');\n        var tmpCtx = tmpCanvas.getContext('2d');\n        tmpCanvas.width = 1;\n        tmpCanvas.height = 1;\n        tmpCtx.fillStyle = color;\n        tmpCtx.fillRect(0, 0, 1, 1);\n        return tmpCtx.getImageData(0, 0, 1, 1).data;\n    }\n\n    var vs_s = [\n        'attribute vec4 a_Position;',\n        'void main() {',\n        'gl_Position = a_Position;',\n        'gl_PointSize = 30.0;',\n        '}',\n    ].join('');\n\n    var fs_s = [\n        'precision mediump float;',\n        'uniform vec4 u_FragColor;',\n        'void main() {',\n        'gl_FragColor = u_FragColor;',\n        '}',\n    ].join('');\n\n    function draw$1(gl, data, options) {\n        if (!data) {\n            return;\n        }\n\n        var program = initShaders(gl, vs_s, fs_s);\n\n        gl.enable(gl.BLEND);\n        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n\n        //gl.clearColor(0.0, 0.0, 1.0, 1.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        var halfCanvasWidth = gl.canvas.width / 2;\n        var halfCanvasHeight = gl.canvas.height / 2;\n\n        // Create a buffer object\n        var vertexBuffer = gl.createBuffer();\n        // Bind the buffer object to target\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n\n        var a_Position = gl.getAttribLocation(program, 'a_Position');\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);\n\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n\n        var uFragColor = gl.getUniformLocation(program, 'u_FragColor');\n\n        var colored = getColorData(options.strokeStyle || 'red');\n\n        gl.uniform4f(uFragColor, colored[0] / 255, colored[1] / 255, colored[2] / 255, colored[3] / 255);\n\n        gl.lineWidth(options.lineWidth || 1);\n\n        for (var i = 0, len = data.length; i < len; i++) {\n            var _geometry = data[i].geometry._coordinates;\n\n            var verticesData = [];\n\n            for (var j = 0; j < _geometry.length; j++) {\n                var item = _geometry[j];\n\n                var x = (item[0] - halfCanvasWidth) / halfCanvasWidth;\n                var y = (halfCanvasHeight - item[1]) / halfCanvasHeight;\n                verticesData.push(x, y);\n            }\n\n            var vertices = new Float32Array(verticesData);\n            // Write date into the buffer object\n            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n            gl.drawArrays(gl.LINE_STRIP, 0, _geometry.length);\n        }\n    }\n\n    var line = {\n        draw: draw$1,\n    };\n\n    var vs_s$1 = [\n        'attribute vec4 a_Position;',\n        'attribute float a_PointSize;',\n        'void main() {',\n        'gl_Position = a_Position;',\n        'gl_PointSize = a_PointSize;',\n        '}',\n    ].join('');\n\n    var fs_s$1 = [\n        'precision mediump float;',\n        'uniform vec4 u_FragColor;',\n        'void main() {',\n        'gl_FragColor = u_FragColor;',\n        '}',\n    ].join('');\n\n    function draw$2(gl, data, options) {\n        if (!data) {\n            return;\n        }\n\n        var program = initShaders(gl, vs_s$1, fs_s$1);\n\n        var a_Position = gl.getAttribLocation(program, 'a_Position');\n\n        var a_PointSize = gl.getAttribLocation(program, 'a_PointSize');\n\n        var uFragColor = gl.getUniformLocation(program, 'u_FragColor');\n\n        //gl.clearColor(0.0, 0.0, 1.0, 1.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        var halfCanvasWidth = gl.canvas.width / 2;\n        var halfCanvasHeight = gl.canvas.height / 2;\n\n        var verticesData = [];\n        var count = 0;\n        for (var i = 0; i < data.length; i++) {\n            var item = data[i].geometry._coordinates;\n\n            var x = (item[0] - halfCanvasWidth) / halfCanvasWidth;\n            var y = (halfCanvasHeight - item[1]) / halfCanvasHeight;\n\n            if (x < -1 || x > 1 || y < -1 || y > 1) {\n                continue;\n            }\n            verticesData.push(x, y);\n            count++;\n        }\n\n        var vertices = new Float32Array(verticesData);\n        var n = count; // The number of vertices\n\n        // Create a buffer object\n        var vertexBuffer = gl.createBuffer();\n\n        // Bind the buffer object to target\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);\n\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n\n        gl.vertexAttrib1f(a_PointSize, options._size);\n\n        var colored = getColorData(options.fillStyle || 'red');\n\n        gl.uniform4f(uFragColor, colored[0] / 255, colored[1] / 255, colored[2] / 255, colored[3] / 255);\n        gl.drawArrays(gl.POINTS, 0, n);\n    }\n\n    var point = {\n        draw: draw$2,\n    };\n\n    function earcut(data, holeIndices, dim) {\n        dim = dim || 2;\n\n        var hasHoles = holeIndices && holeIndices.length,\n            outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n            outerNode = linkedList(data, 0, outerLen, dim, true),\n            triangles = [];\n\n        if (!outerNode) return triangles;\n\n        var minX, minY, maxX, maxY, x, y, size;\n\n        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n        if (data.length > 80 * dim) {\n            minX = maxX = data[0];\n            minY = maxY = data[1];\n\n            for (var i = dim; i < outerLen; i += dim) {\n                x = data[i];\n                y = data[i + 1];\n                if (x < minX) minX = x;\n                if (y < minY) minY = y;\n                if (x > maxX) maxX = x;\n                if (y > maxY) maxY = y;\n            }\n\n            // minX, minY and size are later used to transform coords into integers for z-order calculation\n            size = Math.max(maxX - minX, maxY - minY);\n        }\n\n        earcutLinked(outerNode, triangles, dim, minX, minY, size);\n\n        return triangles;\n    }\n\n    // create a circular doubly linked list from polygon points in the specified winding order\n    function linkedList(data, start, end, dim, clockwise) {\n        var i, last;\n\n        if (clockwise === signedArea(data, start, end, dim) > 0) {\n            for (i = start; i < end; i += dim) {\n                last = insertNode(i, data[i], data[i + 1], last);\n            }\n        } else {\n            for (i = end - dim; i >= start; i -= dim) {\n                last = insertNode(i, data[i], data[i + 1], last);\n            }\n        }\n\n        if (last && equals(last, last.next)) {\n            removeNode(last);\n            last = last.next;\n        }\n\n        return last;\n    }\n\n    // eliminate colinear or duplicate points\n    function filterPoints(start, end) {\n        if (!start) return start;\n        if (!end) end = start;\n\n        var p = start,\n            again;\n        do {\n            again = false;\n\n            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n                removeNode(p);\n                p = end = p.prev;\n                if (p === p.next) return null;\n                again = true;\n            } else {\n                p = p.next;\n            }\n        } while (again || p !== end);\n\n        return end;\n    }\n\n    // main ear slicing loop which triangulates a polygon (given as a linked list)\n    function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {\n        if (!ear) return;\n\n        // interlink polygon nodes in z-order\n        if (!pass && size) indexCurve(ear, minX, minY, size);\n\n        var stop = ear,\n            prev,\n            next;\n\n        // iterate through ears, slicing them one by one\n        while (ear.prev !== ear.next) {\n            prev = ear.prev;\n            next = ear.next;\n\n            if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {\n                // cut off the triangle\n                triangles.push(prev.i / dim);\n                triangles.push(ear.i / dim);\n                triangles.push(next.i / dim);\n\n                removeNode(ear);\n\n                // skipping the next vertice leads to less sliver triangles\n                ear = next.next;\n                stop = next.next;\n\n                continue;\n            }\n\n            ear = next;\n\n            // if we looped through the whole remaining polygon and can't find any more ears\n            if (ear === stop) {\n                // try filtering points and slicing again\n                if (!pass) {\n                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);\n\n                    // if this didn't work, try curing all small self-intersections locally\n                } else if (pass === 1) {\n                    ear = cureLocalIntersections(ear, triangles, dim);\n                    earcutLinked(ear, triangles, dim, minX, minY, size, 2);\n\n                    // as a last resort, try splitting the remaining polygon into two\n                } else if (pass === 2) {\n                    splitEarcut(ear, triangles, dim, minX, minY, size);\n                }\n\n                break;\n            }\n        }\n    }\n\n    // check whether a polygon node forms a valid ear with adjacent nodes\n    function isEar(ear) {\n        var a = ear.prev,\n            b = ear,\n            c = ear.next;\n\n        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n        // now make sure we don't have other points inside the potential ear\n        var p = ear.next.next;\n\n        while (p !== ear.prev) {\n            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n            p = p.next;\n        }\n\n        return true;\n    }\n\n    function isEarHashed(ear, minX, minY, size) {\n        var a = ear.prev,\n            b = ear,\n            c = ear.next;\n\n        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n        // triangle bbox; min & max are calculated like this for speed\n        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : b.x < c.x ? b.x : c.x,\n            minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : b.y < c.y ? b.y : c.y,\n            maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : b.x > c.x ? b.x : c.x,\n            maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : b.y > c.y ? b.y : c.y;\n\n        // z-order range for the current triangle bbox;\n        var minZ = zOrder(minTX, minTY, minX, minY, size),\n            maxZ = zOrder(maxTX, maxTY, minX, minY, size);\n\n        // first look for points inside the triangle in increasing z-order\n        var p = ear.nextZ;\n\n        while (p && p.z <= maxZ) {\n            if (\n                p !== ear.prev &&\n                p !== ear.next &&\n                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n                area(p.prev, p, p.next) >= 0\n            )\n                return false;\n            p = p.nextZ;\n        }\n\n        // then look for points in decreasing z-order\n        p = ear.prevZ;\n\n        while (p && p.z >= minZ) {\n            if (\n                p !== ear.prev &&\n                p !== ear.next &&\n                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n                area(p.prev, p, p.next) >= 0\n            )\n                return false;\n            p = p.prevZ;\n        }\n\n        return true;\n    }\n\n    // go through all polygon nodes and cure small local self-intersections\n    function cureLocalIntersections(start, triangles, dim) {\n        var p = start;\n        do {\n            var a = p.prev,\n                b = p.next.next;\n\n            if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n                triangles.push(a.i / dim);\n                triangles.push(p.i / dim);\n                triangles.push(b.i / dim);\n\n                // remove two nodes involved\n                removeNode(p);\n                removeNode(p.next);\n\n                p = start = b;\n            }\n            p = p.next;\n        } while (p !== start);\n\n        return p;\n    }\n\n    // try splitting polygon into two and triangulate them independently\n    function splitEarcut(start, triangles, dim, minX, minY, size) {\n        // look for a valid diagonal that divides the polygon into two\n        var a = start;\n        do {\n            var b = a.next.next;\n            while (b !== a.prev) {\n                if (a.i !== b.i && isValidDiagonal(a, b)) {\n                    // split the polygon in two by the diagonal\n                    var c = splitPolygon(a, b);\n\n                    // filter colinear points around the cuts\n                    a = filterPoints(a, a.next);\n                    c = filterPoints(c, c.next);\n\n                    // run earcut on each half\n                    earcutLinked(a, triangles, dim, minX, minY, size);\n                    earcutLinked(c, triangles, dim, minX, minY, size);\n                    return;\n                }\n                b = b.next;\n            }\n            a = a.next;\n        } while (a !== start);\n    }\n\n    // link every hole into the outer loop, producing a single-ring polygon without holes\n    function eliminateHoles(data, holeIndices, outerNode, dim) {\n        var queue = [],\n            i,\n            len,\n            start,\n            end,\n            list;\n\n        for (i = 0, len = holeIndices.length; i < len; i++) {\n            start = holeIndices[i] * dim;\n            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            list = linkedList(data, start, end, dim, false);\n            if (list === list.next) list.steiner = true;\n            queue.push(getLeftmost(list));\n        }\n\n        queue.sort(compareX);\n\n        // process holes from left to right\n        for (i = 0; i < queue.length; i++) {\n            eliminateHole(queue[i], outerNode);\n            outerNode = filterPoints(outerNode, outerNode.next);\n        }\n\n        return outerNode;\n    }\n\n    function compareX(a, b) {\n        return a.x - b.x;\n    }\n\n    // find a bridge between vertices that connects hole with an outer ring and and link it\n    function eliminateHole(hole, outerNode) {\n        outerNode = findHoleBridge(hole, outerNode);\n        if (outerNode) {\n            var b = splitPolygon(outerNode, hole);\n            filterPoints(b, b.next);\n        }\n    }\n\n    // David Eberly's algorithm for finding a bridge between hole and outer polygon\n    function findHoleBridge(hole, outerNode) {\n        var p = outerNode,\n            hx = hole.x,\n            hy = hole.y,\n            qx = -Infinity,\n            m;\n\n        // find a segment intersected by a ray from the hole's leftmost point to the left;\n        // segment's endpoint with lesser x will be potential connection point\n        do {\n            if (hy <= p.y && hy >= p.next.y) {\n                var x = p.x + ((hy - p.y) * (p.next.x - p.x)) / (p.next.y - p.y);\n                if (x <= hx && x > qx) {\n                    qx = x;\n                    if (x === hx) {\n                        if (hy === p.y) return p;\n                        if (hy === p.next.y) return p.next;\n                    }\n                    m = p.x < p.next.x ? p : p.next;\n                }\n            }\n            p = p.next;\n        } while (p !== outerNode);\n\n        if (!m) return null;\n\n        if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint\n\n        // look for points inside the triangle of hole point, segment intersection and endpoint;\n        // if there are no points found, we have a valid connection;\n        // otherwise choose the point of the minimum angle with the ray as connection point\n\n        var stop = m,\n            mx = m.x,\n            my = m.y,\n            tanMin = Infinity,\n            tan;\n\n        p = m.next;\n\n        while (p !== stop) {\n            if (\n                hx >= p.x &&\n                p.x >= mx &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)\n            ) {\n                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {\n                    m = p;\n                    tanMin = tan;\n                }\n            }\n\n            p = p.next;\n        }\n\n        return m;\n    }\n\n    // interlink polygon nodes in z-order\n    function indexCurve(start, minX, minY, size) {\n        var p = start;\n        do {\n            if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);\n            p.prevZ = p.prev;\n            p.nextZ = p.next;\n            p = p.next;\n        } while (p !== start);\n\n        p.prevZ.nextZ = null;\n        p.prevZ = null;\n\n        sortLinked(p);\n    }\n\n    // Simon Tatham's linked list merge sort algorithm\n    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n    function sortLinked(list) {\n        var i,\n            p,\n            q,\n            e,\n            tail,\n            numMerges,\n            pSize,\n            qSize,\n            inSize = 1;\n\n        do {\n            p = list;\n            list = null;\n            tail = null;\n            numMerges = 0;\n\n            while (p) {\n                numMerges++;\n                q = p;\n                pSize = 0;\n                for (i = 0; i < inSize; i++) {\n                    pSize++;\n                    q = q.nextZ;\n                    if (!q) break;\n                }\n\n                qSize = inSize;\n\n                while (pSize > 0 || (qSize > 0 && q)) {\n                    if (pSize === 0) {\n                        e = q;\n                        q = q.nextZ;\n                        qSize--;\n                    } else if (qSize === 0 || !q) {\n                        e = p;\n                        p = p.nextZ;\n                        pSize--;\n                    } else if (p.z <= q.z) {\n                        e = p;\n                        p = p.nextZ;\n                        pSize--;\n                    } else {\n                        e = q;\n                        q = q.nextZ;\n                        qSize--;\n                    }\n\n                    if (tail) tail.nextZ = e;\n                    else list = e;\n\n                    e.prevZ = tail;\n                    tail = e;\n                }\n\n                p = q;\n            }\n\n            tail.nextZ = null;\n            inSize *= 2;\n        } while (numMerges > 1);\n\n        return list;\n    }\n\n    // z-order of a point given coords and size of the data bounding box\n    function zOrder(x, y, minX, minY, size) {\n        // coords are transformed into non-negative 15-bit integer range\n        x = (32767 * (x - minX)) / size;\n        y = (32767 * (y - minY)) / size;\n\n        x = (x | (x << 8)) & 0x00ff00ff;\n        x = (x | (x << 4)) & 0x0f0f0f0f;\n        x = (x | (x << 2)) & 0x33333333;\n        x = (x | (x << 1)) & 0x55555555;\n\n        y = (y | (y << 8)) & 0x00ff00ff;\n        y = (y | (y << 4)) & 0x0f0f0f0f;\n        y = (y | (y << 2)) & 0x33333333;\n        y = (y | (y << 1)) & 0x55555555;\n\n        return x | (y << 1);\n    }\n\n    // find the leftmost node of a polygon ring\n    function getLeftmost(start) {\n        var p = start,\n            leftmost = start;\n        do {\n            if (p.x < leftmost.x) leftmost = p;\n            p = p.next;\n        } while (p !== start);\n\n        return leftmost;\n    }\n\n    // check if a point lies within a convex triangle\n    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n        return (\n            (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0\n        );\n    }\n\n    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n    function isValidDiagonal(a, b) {\n        return (\n            a.next.i !== b.i &&\n            a.prev.i !== b.i &&\n            !intersectsPolygon(a, b) &&\n            locallyInside(a, b) &&\n            locallyInside(b, a) &&\n            middleInside(a, b)\n        );\n    }\n\n    // signed area of a triangle\n    function area(p, q, r) {\n        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    }\n\n    // check if two points are equal\n    function equals(p1, p2) {\n        return p1.x === p2.x && p1.y === p2.y;\n    }\n\n    // check if two segments intersect\n    function intersects(p1, q1, p2, q2) {\n        if ((equals(p1, q1) && equals(p2, q2)) || (equals(p1, q2) && equals(p2, q1))) return true;\n        return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;\n    }\n\n    // check if a polygon diagonal intersects any polygon segments\n    function intersectsPolygon(a, b) {\n        var p = a;\n        do {\n            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))\n                return true;\n            p = p.next;\n        } while (p !== a);\n\n        return false;\n    }\n\n    // check if a polygon diagonal is locally inside the polygon\n    function locallyInside(a, b) {\n        return area(a.prev, a, a.next) < 0\n            ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0\n            : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n    }\n\n    // check if the middle point of a polygon diagonal is inside the polygon\n    function middleInside(a, b) {\n        var p = a,\n            inside = false,\n            px = (a.x + b.x) / 2,\n            py = (a.y + b.y) / 2;\n        do {\n            if (p.y > py !== p.next.y > py && px < ((p.next.x - p.x) * (py - p.y)) / (p.next.y - p.y) + p.x)\n                inside = !inside;\n            p = p.next;\n        } while (p !== a);\n\n        return inside;\n    }\n\n    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n    // if one belongs to the outer ring and another to a hole, it merges it into a single ring\n    function splitPolygon(a, b) {\n        var a2 = new Node(a.i, a.x, a.y),\n            b2 = new Node(b.i, b.x, b.y),\n            an = a.next,\n            bp = b.prev;\n\n        a.next = b;\n        b.prev = a;\n\n        a2.next = an;\n        an.prev = a2;\n\n        b2.next = a2;\n        a2.prev = b2;\n\n        bp.next = b2;\n        b2.prev = bp;\n\n        return b2;\n    }\n\n    // create a node and optionally link it with previous one (in a circular doubly linked list)\n    function insertNode(i, x, y, last) {\n        var p = new Node(i, x, y);\n\n        if (!last) {\n            p.prev = p;\n            p.next = p;\n        } else {\n            p.next = last.next;\n            p.prev = last;\n            last.next.prev = p;\n            last.next = p;\n        }\n        return p;\n    }\n\n    function removeNode(p) {\n        p.next.prev = p.prev;\n        p.prev.next = p.next;\n\n        if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n        if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n    }\n\n    function Node(i, x, y) {\n        // vertice index in coordinates array\n        this.i = i;\n\n        // vertex coordinates\n        this.x = x;\n        this.y = y;\n\n        // previous and next vertice nodes in a polygon ring\n        this.prev = null;\n        this.next = null;\n\n        // z-order curve value\n        this.z = null;\n\n        // previous and next nodes in z-order\n        this.prevZ = null;\n        this.nextZ = null;\n\n        // indicates whether this is a steiner point\n        this.steiner = false;\n    }\n\n    // return a percentage difference between the polygon area and its triangulation area;\n    // used to verify correctness of triangulation\n    earcut.deviation = function (data, holeIndices, dim, triangles) {\n        var hasHoles = holeIndices && holeIndices.length;\n        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n        if (hasHoles) {\n            for (var i = 0, len = holeIndices.length; i < len; i++) {\n                var start = holeIndices[i] * dim;\n                var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n                polygonArea -= Math.abs(signedArea(data, start, end, dim));\n            }\n        }\n\n        var trianglesArea = 0;\n        for (i = 0; i < triangles.length; i += 3) {\n            var a = triangles[i] * dim;\n            var b = triangles[i + 1] * dim;\n            var c = triangles[i + 2] * dim;\n            trianglesArea += Math.abs(\n                (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])\n            );\n        }\n\n        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);\n    };\n\n    function signedArea(data, start, end, dim) {\n        var sum = 0;\n        for (var i = start, j = end - dim; i < end; i += dim) {\n            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n            j = i;\n        }\n        return sum;\n    }\n\n    // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\n    earcut.flatten = function (data) {\n        var dim = data[0][0].length,\n            result = {\n                vertices: [],\n                holes: [],\n                dimensions: dim,\n            },\n            holeIndex = 0;\n\n        for (var i = 0; i < data.length; i++) {\n            for (var j = 0; j < data[i].length; j++) {\n                for (var d = 0; d < dim; d++) {\n                    result.vertices.push(data[i][j][d]);\n                }\n            }\n            if (i > 0) {\n                holeIndex += data[i - 1].length;\n                result.holes.push(holeIndex);\n            }\n        }\n        return result;\n    };\n\n    var vs_s$2 = [\n        'attribute vec4 a_Position;',\n        'void main() {',\n        'gl_Position = a_Position;',\n        'gl_PointSize = 30.0;',\n        '}',\n    ].join('');\n\n    var fs_s$2 = [\n        'precision mediump float;',\n        'uniform vec4 u_FragColor;',\n        'void main() {',\n        'gl_FragColor = u_FragColor;',\n        '}',\n    ].join('');\n\n    function draw$3(gl, data, options) {\n        if (!data) {\n            return;\n        }\n\n        // gl.clearColor(0.0, 0.0, 0.0, 1.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n        var program = initShaders(gl, vs_s$2, fs_s$2);\n\n        gl.enable(gl.BLEND);\n        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n\n        var halfCanvasWidth = gl.canvas.width / 2;\n        var halfCanvasHeight = gl.canvas.height / 2;\n\n        // Bind the buffer object to target\n        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n\n        var a_Position = gl.getAttribLocation(program, 'a_Position');\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);\n\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n\n        var uFragColor = gl.getUniformLocation(program, 'u_FragColor');\n\n        var colored = getColorData(options.fillStyle || 'red');\n\n        gl.uniform4f(uFragColor, colored[0] / 255, colored[1] / 255, colored[2] / 255, colored[3] / 255);\n\n        gl.lineWidth(options.lineWidth || 1);\n\n        var verticesArr = [];\n        var trianglesArr = [];\n\n        var maxSize = 65536;\n        var indexOffset = 0;\n\n        for (var i = 0, len = data.length; i < len; i++) {\n            var flatten = earcut.flatten(data[i].geometry._coordinates || data[i].geometry.coordinates);\n            var vertices = flatten.vertices;\n            indexOffset = verticesArr.length / 2;\n            for (var j = 0; j < vertices.length; j += 2) {\n                vertices[j] = (vertices[j] - halfCanvasWidth) / halfCanvasWidth;\n                vertices[j + 1] = (halfCanvasHeight - vertices[j + 1]) / halfCanvasHeight;\n            }\n\n            if ((verticesArr.length + vertices.length) / 2 > maxSize) {\n                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArr), gl.STATIC_DRAW);\n                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(trianglesArr), gl.STATIC_DRAW);\n                gl.drawElements(gl.TRIANGLES, trianglesArr.length, gl.UNSIGNED_SHORT, 0);\n                verticesArr.length = 0;\n                trianglesArr.length = 0;\n                indexOffset = 0;\n            }\n\n            for (var j = 0; j < vertices.length; j++) {\n                verticesArr.push(vertices[j]);\n            }\n\n            var triangles = earcut(vertices, flatten.holes, flatten.dimensions);\n            for (var j = 0; j < triangles.length; j++) {\n                trianglesArr.push(triangles[j] + indexOffset);\n            }\n        }\n\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArr), gl.STATIC_DRAW);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(trianglesArr), gl.STATIC_DRAW);\n        gl.drawElements(gl.TRIANGLES, trianglesArr.length, gl.UNSIGNED_SHORT, 0);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n\n    var polygon = {\n        draw: draw$3,\n    };\n\n    /**\n     * @author kyle / http://nikai.us/\n     */\n    var webglDrawSimple = {\n        draw: function draw(gl, dataSet, options) {\n            var data = dataSet instanceof DataSet ? dataSet.get() : dataSet;\n            if (data.length > 0) {\n                if (data[0].geometry.type == 'LineString') {\n                    line.draw(gl, data, options);\n                } else if (data[0].geometry.type == 'Polygon' || data[0].geometry.type == 'MultiPolygon') {\n                    polygon.draw(gl, data, options);\n                } else {\n                    point.draw(gl, data, options);\n                }\n            }\n        },\n    };\n\n    /**\n     * get the center by the city name\n     * @author kyle / http://nikai.us/\n     */\n\n    function getCenter(g) {\n        var item = g.split('|');\n        item[0] = item[0].split(',');\n        return {\n            lng: parseFloat(item[0][0]),\n            lat: parseFloat(item[0][1]),\n        };\n    }\n\n    var cityCenter = {\n        getCenterByCityName: function getCenterByCityName(name) {\n            for (var i = 0; i < citycenter.municipalities.length; i++) {\n                if (citycenter.municipalities[i].n == name) {\n                    return getCenter(citycenter.municipalities[i].g);\n                }\n            }\n\n            var provinces = citycenter.provinces;\n            for (var i = 0; i < provinces.length; i++) {\n                if (provinces[i].n == name) {\n                    return getCenter(provinces[i].g);\n                }\n                var cities = provinces[i].cities;\n                for (var j = 0; j < cities.length; j++) {\n                    if (cities[j].n == name) {\n                        return getCenter(cities[j].g);\n                    }\n                }\n            }\n            return null;\n        },\n    };\n\n    /**\n     * 根据弧线的坐标节点数组\n     */\n    function getCurvePoints(points) {\n        var curvePoints = [];\n        for (var i = 0; i < points.length - 1; i++) {\n            var p = getCurveByTwoPoints(points[i], points[i + 1]);\n            if (p && p.length > 0) {\n                curvePoints = curvePoints.concat(p);\n            }\n        }\n        return curvePoints;\n    }\n\n    /**\n     * 根据两点获取曲线坐标点数组\n     * @param Point 起点\n     * @param Point 终点\n     */\n    function getCurveByTwoPoints(obj1, obj2) {\n        if (!obj1 || !obj2) {\n            return null;\n        }\n\n        var B1 = function B1(x) {\n            return 1 - 2 * x + x * x;\n        };\n        var B2 = function B2(x) {\n            return 2 * x - 2 * x * x;\n        };\n        var B3 = function B3(x) {\n            return x * x;\n        };\n\n        var curveCoordinates = [];\n\n        var count = 40; // 曲线是由一些小的线段组成的，这个表示这个曲线所有到的折线的个数\n        var isFuture = false;\n        var t, h, h2, lat3, lng3, j, t2;\n        var LnArray = [];\n        var i = 0;\n        var inc = 0;\n\n        if (typeof obj2 == 'undefined') {\n            if (typeof curveCoordinates != 'undefined') {\n                curveCoordinates = [];\n            }\n            return;\n        }\n\n        var lat1 = parseFloat(obj1.lat);\n        var lat2 = parseFloat(obj2.lat);\n        var lng1 = parseFloat(obj1.lng);\n        var lng2 = parseFloat(obj2.lng);\n\n        // 计算曲线角度的方法\n        if (lng2 > lng1) {\n            if (parseFloat(lng2 - lng1) > 180) {\n                if (lng1 < 0) {\n                    lng1 = parseFloat(180 + 180 + lng1);\n                }\n            }\n        }\n\n        if (lng1 > lng2) {\n            if (parseFloat(lng1 - lng2) > 180) {\n                if (lng2 < 0) {\n                    lng2 = parseFloat(180 + 180 + lng2);\n                }\n            }\n        }\n        j = 0;\n        t2 = 0;\n        if (lat2 == lat1) {\n            t = 0;\n            h = lng1 - lng2;\n        } else if (lng2 == lng1) {\n            t = Math.PI / 2;\n            h = lat1 - lat2;\n        } else {\n            t = Math.atan((lat2 - lat1) / (lng2 - lng1));\n            h = (lat2 - lat1) / Math.sin(t);\n        }\n        if (t2 == 0) {\n            t2 = t + Math.PI / 5;\n        }\n        h2 = h / 2;\n        lng3 = h2 * Math.cos(t2) + lng1;\n        lat3 = h2 * Math.sin(t2) + lat1;\n\n        for (i = 0; i < count + 1; i++) {\n            curveCoordinates.push([\n                lng1 * B1(inc) + lng3 * B2(inc) + lng2 * B3(inc),\n                lat1 * B1(inc) + lat3 * B2(inc) + lat2 * B3(inc),\n            ]);\n            inc = inc + 1 / count;\n        }\n        return curveCoordinates;\n    }\n\n    var curve = {\n        getPoints: getCurvePoints,\n    };\n\n    /* \n    FDEB algorithm implementation [www.win.tue.nl/~dholten/papers/forcebundles_eurovis.pdf].\n\n    Author:  (github.com/upphiminn)\n    2013\n\n    */\n\n    var ForceEdgeBundling = function ForceEdgeBundling() {\n        var data_nodes = {},\n            // {'nodeid':{'x':,'y':},..}\n            data_edges = [],\n            // [{'source':'nodeid1', 'target':'nodeid2'},..]\n            compatibility_list_for_edge = [],\n            subdivision_points_for_edge = [],\n            K = 0.1,\n            // global bundling constant controling edge stiffness\n            S_initial = 0.1,\n            // init. distance to move points\n            P_initial = 1,\n            // init. subdivision number\n            P_rate = 2,\n            // subdivision rate increase\n            C = 6,\n            // number of cycles to perform\n            I_initial = 70,\n            // init. number of iterations for cycle\n            I_rate = 0.6666667,\n            // rate at which iteration number decreases i.e. 2/3\n            compatibility_threshold = 0.6,\n            invers_quadratic_mode = false,\n            eps = 1e-8;\n\n        /*** Geometry Helper Methods ***/\n        function vector_dot_product(p, q) {\n            return p.x * q.x + p.y * q.y;\n        }\n\n        function edge_as_vector(P) {\n            return {\n                x: data_nodes[P.target].x - data_nodes[P.source].x,\n                y: data_nodes[P.target].y - data_nodes[P.source].y,\n            };\n        }\n\n        function edge_length(e) {\n            return Math.sqrt(\n                Math.pow(data_nodes[e.source].x - data_nodes[e.target].x, 2) +\n                    Math.pow(data_nodes[e.source].y - data_nodes[e.target].y, 2)\n            );\n        }\n\n        function custom_edge_length(e) {\n            return Math.sqrt(Math.pow(e.source.x - e.target.x, 2) + Math.pow(e.source.y - e.target.y, 2));\n        }\n\n        function edge_midpoint(e) {\n            var middle_x = (data_nodes[e.source].x + data_nodes[e.target].x) / 2.0;\n            var middle_y = (data_nodes[e.source].y + data_nodes[e.target].y) / 2.0;\n            return {\n                x: middle_x,\n                y: middle_y,\n            };\n        }\n\n        function compute_divided_edge_length(e_idx) {\n            var length = 0;\n            for (var i = 1; i < subdivision_points_for_edge[e_idx].length; i++) {\n                var segment_length = euclidean_distance(\n                    subdivision_points_for_edge[e_idx][i],\n                    subdivision_points_for_edge[e_idx][i - 1]\n                );\n                length += segment_length;\n            }\n            return length;\n        }\n\n        function euclidean_distance(p, q) {\n            return Math.sqrt(Math.pow(p.x - q.x, 2) + Math.pow(p.y - q.y, 2));\n        }\n\n        function project_point_on_line(p, Q) {\n            var L = Math.sqrt(\n                (Q.target.x - Q.source.x) * (Q.target.x - Q.source.x) +\n                    (Q.target.y - Q.source.y) * (Q.target.y - Q.source.y)\n            );\n            var r =\n                ((Q.source.y - p.y) * (Q.source.y - Q.target.y) - (Q.source.x - p.x) * (Q.target.x - Q.source.x)) /\n                (L * L);\n\n            return {\n                x: Q.source.x + r * (Q.target.x - Q.source.x),\n                y: Q.source.y + r * (Q.target.y - Q.source.y),\n            };\n        }\n\n        /*** ********************** ***/\n\n        /*** Initialization Methods ***/\n        function initialize_edge_subdivisions() {\n            for (var i = 0; i < data_edges.length; i++) {\n                if (P_initial == 1) subdivision_points_for_edge[i] = [];\n                //0 subdivisions\n                else {\n                    subdivision_points_for_edge[i] = [];\n                    subdivision_points_for_edge[i].push(data_nodes[data_edges[i].source]);\n                    subdivision_points_for_edge[i].push(data_nodes[data_edges[i].target]);\n                }\n            }\n        }\n\n        function initialize_compatibility_lists() {\n            for (var i = 0; i < data_edges.length; i++) {\n                compatibility_list_for_edge[i] = [];\n            } //0 compatible edges.\n        }\n\n        function filter_self_loops(edgelist) {\n            var filtered_edge_list = [];\n            for (var e = 0; e < edgelist.length; e++) {\n                if (\n                    data_nodes[edgelist[e].source].x != data_nodes[edgelist[e].target].x &&\n                    data_nodes[edgelist[e].source].y != data_nodes[edgelist[e].target].y\n                ) {\n                    //or smaller than eps\n                    filtered_edge_list.push(edgelist[e]);\n                }\n            }\n\n            return filtered_edge_list;\n        }\n        /*** ********************** ***/\n\n        /*** Force Calculation Methods ***/\n        function apply_spring_force(e_idx, i, kP) {\n            var prev = subdivision_points_for_edge[e_idx][i - 1];\n            var next = subdivision_points_for_edge[e_idx][i + 1];\n            var crnt = subdivision_points_for_edge[e_idx][i];\n\n            var x = prev.x - crnt.x + next.x - crnt.x;\n            var y = prev.y - crnt.y + next.y - crnt.y;\n\n            x *= kP;\n            y *= kP;\n\n            return {\n                x: x,\n                y: y,\n            };\n        }\n\n        function apply_electrostatic_force(e_idx, i, S) {\n            var sum_of_forces = {\n                x: 0,\n                y: 0,\n            };\n            var compatible_edges_list = compatibility_list_for_edge[e_idx];\n\n            for (var oe = 0; oe < compatible_edges_list.length; oe++) {\n                var force = {\n                    x:\n                        subdivision_points_for_edge[compatible_edges_list[oe]][i].x -\n                        subdivision_points_for_edge[e_idx][i].x,\n                    y:\n                        subdivision_points_for_edge[compatible_edges_list[oe]][i].y -\n                        subdivision_points_for_edge[e_idx][i].y,\n                };\n\n                if (Math.abs(force.x) > eps || Math.abs(force.y) > eps) {\n                    var diff =\n                        1 /\n                        Math.pow(\n                            custom_edge_length({\n                                source: subdivision_points_for_edge[compatible_edges_list[oe]][i],\n                                target: subdivision_points_for_edge[e_idx][i],\n                            }),\n                            1\n                        );\n\n                    sum_of_forces.x += force.x * diff;\n                    sum_of_forces.y += force.y * diff;\n                }\n            }\n            return sum_of_forces;\n        }\n\n        function apply_resulting_forces_on_subdivision_points(e_idx, P, S) {\n            var kP = K / (edge_length(data_edges[e_idx]) * (P + 1)); // kP=K/|P|(number of segments), where |P| is the initial length of edge P.\n            // (length * (num of sub division pts - 1))\n            var resulting_forces_for_subdivision_points = [\n                {\n                    x: 0,\n                    y: 0,\n                },\n            ];\n            for (var i = 1; i < P + 1; i++) {\n                // exclude initial end points of the edge 0 and P+1\n                var resulting_force = {\n                    x: 0,\n                    y: 0,\n                };\n\n                var spring_force = apply_spring_force(e_idx, i, kP);\n                var electrostatic_force = apply_electrostatic_force(e_idx, i, S);\n\n                resulting_force.x = S * (spring_force.x + electrostatic_force.x);\n                resulting_force.y = S * (spring_force.y + electrostatic_force.y);\n\n                resulting_forces_for_subdivision_points.push(resulting_force);\n            }\n            resulting_forces_for_subdivision_points.push({\n                x: 0,\n                y: 0,\n            });\n            return resulting_forces_for_subdivision_points;\n        }\n        /*** ********************** ***/\n\n        /*** Edge Division Calculation Methods ***/\n        function update_edge_divisions(P) {\n            for (var e_idx = 0; e_idx < data_edges.length; e_idx++) {\n                if (P == 1) {\n                    subdivision_points_for_edge[e_idx].push(data_nodes[data_edges[e_idx].source]); // source\n                    subdivision_points_for_edge[e_idx].push(edge_midpoint(data_edges[e_idx])); // mid point\n                    subdivision_points_for_edge[e_idx].push(data_nodes[data_edges[e_idx].target]); // target\n                } else {\n                    var divided_edge_length = compute_divided_edge_length(e_idx);\n                    var segment_length = divided_edge_length / (P + 1);\n                    var current_segment_length = segment_length;\n                    var new_subdivision_points = [];\n                    new_subdivision_points.push(data_nodes[data_edges[e_idx].source]); //source\n\n                    for (var i = 1; i < subdivision_points_for_edge[e_idx].length; i++) {\n                        var old_segment_length = euclidean_distance(\n                            subdivision_points_for_edge[e_idx][i],\n                            subdivision_points_for_edge[e_idx][i - 1]\n                        );\n\n                        while (old_segment_length > current_segment_length) {\n                            var percent_position = current_segment_length / old_segment_length;\n                            var new_subdivision_point_x = subdivision_points_for_edge[e_idx][i - 1].x;\n                            var new_subdivision_point_y = subdivision_points_for_edge[e_idx][i - 1].y;\n\n                            new_subdivision_point_x +=\n                                percent_position *\n                                (subdivision_points_for_edge[e_idx][i].x - subdivision_points_for_edge[e_idx][i - 1].x);\n                            new_subdivision_point_y +=\n                                percent_position *\n                                (subdivision_points_for_edge[e_idx][i].y - subdivision_points_for_edge[e_idx][i - 1].y);\n                            new_subdivision_points.push({\n                                x: new_subdivision_point_x,\n                                y: new_subdivision_point_y,\n                            });\n\n                            old_segment_length -= current_segment_length;\n                            current_segment_length = segment_length;\n                        }\n                        current_segment_length -= old_segment_length;\n                    }\n                    new_subdivision_points.push(data_nodes[data_edges[e_idx].target]); //target\n                    subdivision_points_for_edge[e_idx] = new_subdivision_points;\n                }\n            }\n        }\n        /*** ********************** ***/\n\n        /*** Edge compatibility measures ***/\n        function angle_compatibility(P, Q) {\n            var result = Math.abs(\n                vector_dot_product(edge_as_vector(P), edge_as_vector(Q)) / (edge_length(P) * edge_length(Q))\n            );\n            return result;\n        }\n\n        function scale_compatibility(P, Q) {\n            var lavg = (edge_length(P) + edge_length(Q)) / 2.0;\n            var result =\n                2.0 /\n                (lavg / Math.min(edge_length(P), edge_length(Q)) + Math.max(edge_length(P), edge_length(Q)) / lavg);\n            return result;\n        }\n\n        function position_compatibility(P, Q) {\n            var lavg = (edge_length(P) + edge_length(Q)) / 2.0;\n            var midP = {\n                x: (data_nodes[P.source].x + data_nodes[P.target].x) / 2.0,\n                y: (data_nodes[P.source].y + data_nodes[P.target].y) / 2.0,\n            };\n            var midQ = {\n                x: (data_nodes[Q.source].x + data_nodes[Q.target].x) / 2.0,\n                y: (data_nodes[Q.source].y + data_nodes[Q.target].y) / 2.0,\n            };\n            var result = lavg / (lavg + euclidean_distance(midP, midQ));\n            return result;\n        }\n\n        function edge_visibility(P, Q) {\n            var I0 = project_point_on_line(data_nodes[Q.source], {\n                source: data_nodes[P.source],\n                target: data_nodes[P.target],\n            });\n            var I1 = project_point_on_line(data_nodes[Q.target], {\n                source: data_nodes[P.source],\n                target: data_nodes[P.target],\n            }); //send acutal edge points positions\n            var midI = {\n                x: (I0.x + I1.x) / 2.0,\n                y: (I0.y + I1.y) / 2.0,\n            };\n            var midP = {\n                x: (data_nodes[P.source].x + data_nodes[P.target].x) / 2.0,\n                y: (data_nodes[P.source].y + data_nodes[P.target].y) / 2.0,\n            };\n            var result = Math.max(0, 1 - (2 * euclidean_distance(midP, midI)) / euclidean_distance(I0, I1));\n            return result;\n        }\n\n        function visibility_compatibility(P, Q) {\n            return Math.min(edge_visibility(P, Q), edge_visibility(Q, P));\n        }\n\n        function compatibility_score(P, Q) {\n            var result =\n                angle_compatibility(P, Q) *\n                scale_compatibility(P, Q) *\n                position_compatibility(P, Q) *\n                visibility_compatibility(P, Q);\n\n            return result;\n        }\n\n        function are_compatible(P, Q) {\n            // console.log('compatibility ' + P.source +' - '+ P.target + ' and ' + Q.source +' '+ Q.target);\n            return compatibility_score(P, Q) >= compatibility_threshold;\n        }\n\n        function compute_compatibility_lists() {\n            for (var e = 0; e < data_edges.length - 1; e++) {\n                for (var oe = e + 1; oe < data_edges.length; oe++) {\n                    // don't want any duplicates\n                    if (e == oe) continue;\n                    else {\n                        if (are_compatible(data_edges[e], data_edges[oe])) {\n                            compatibility_list_for_edge[e].push(oe);\n                            compatibility_list_for_edge[oe].push(e);\n                        }\n                    }\n                }\n            }\n        }\n\n        /*** ************************ ***/\n\n        /*** Main Bundling Loop Methods ***/\n        var forcebundle = function forcebundle() {\n            var S = S_initial;\n            var I = I_initial;\n            var P = P_initial;\n\n            initialize_edge_subdivisions();\n            initialize_compatibility_lists();\n            update_edge_divisions(P);\n            compute_compatibility_lists();\n            for (var cycle = 0; cycle < C; cycle++) {\n                for (var iteration = 0; iteration < I; iteration++) {\n                    var forces = [];\n                    for (var edge = 0; edge < data_edges.length; edge++) {\n                        forces[edge] = apply_resulting_forces_on_subdivision_points(edge, P, S);\n                    }\n                    for (var e = 0; e < data_edges.length; e++) {\n                        for (var i = 0; i < P + 1; i++) {\n                            subdivision_points_for_edge[e][i].x += forces[e][i].x;\n                            subdivision_points_for_edge[e][i].y += forces[e][i].y;\n                        }\n                    }\n                }\n                //prepare for next cycle\n                S = S / 2;\n                P = P * 2;\n                I = I_rate * I;\n\n                update_edge_divisions(P);\n                // console.log('C' + cycle);\n                // console.log('P' + P);\n                // console.log('S' + S);\n            }\n            return subdivision_points_for_edge;\n        };\n        /*** ************************ ***/\n\n        /*** Getters/Setters Methods ***/\n        forcebundle.nodes = function (nl) {\n            if (arguments.length == 0) {\n                return data_nodes;\n            } else {\n                data_nodes = nl;\n            }\n            return forcebundle;\n        };\n\n        forcebundle.edges = function (ll) {\n            if (arguments.length == 0) {\n                return data_edges;\n            } else {\n                data_edges = filter_self_loops(ll); //remove edges to from to the same point\n            }\n            return forcebundle;\n        };\n\n        forcebundle.bundling_stiffness = function (k) {\n            if (arguments.length == 0) {\n                return K;\n            } else {\n                K = k;\n            }\n            return forcebundle;\n        };\n\n        forcebundle.step_size = function (step) {\n            if (arguments.length == 0) {\n                return S_initial;\n            } else {\n                S_initial = step;\n            }\n            return forcebundle;\n        };\n\n        forcebundle.cycles = function (c) {\n            if (arguments.length == 0) {\n                return C;\n            } else {\n                C = c;\n            }\n            return forcebundle;\n        };\n\n        forcebundle.iterations = function (i) {\n            if (arguments.length == 0) {\n                return I_initial;\n            } else {\n                I_initial = i;\n            }\n            return forcebundle;\n        };\n\n        forcebundle.iterations_rate = function (i) {\n            if (arguments.length == 0) {\n                return I_rate;\n            } else {\n                I_rate = i;\n            }\n            return forcebundle;\n        };\n\n        forcebundle.subdivision_points_seed = function (p) {\n            if (arguments.length == 0) {\n                return P;\n            } else {\n                P = p;\n            }\n            return forcebundle;\n        };\n\n        forcebundle.subdivision_rate = function (r) {\n            if (arguments.length == 0) {\n                return P_rate;\n            } else {\n                P_rate = r;\n            }\n            return forcebundle;\n        };\n\n        forcebundle.compatbility_threshold = function (t) {\n            if (arguments.length == 0) {\n                return compatbility_threshold;\n            } else {\n                compatibility_threshold = t;\n            }\n            return forcebundle;\n        };\n\n        /*** ************************ ***/\n\n        return forcebundle;\n    };\n\n    /**\n     * @author kyle / http://nikai.us/\n     */\n\n    /**\n     * Category\n     * @param {Object} splitList:\n     *   {\n     *       other: 1,\n     *       1: 2,\n     *       2: 3,\n     *       3: 4,\n     *       4: 5,\n     *       5: 6,\n     *       6: 7\n     *   }\n     */\n    function Category(splitList) {\n        this.splitList = splitList || {\n            other: 1,\n        };\n    }\n\n    Category.prototype.get = function (count) {\n        var splitList = this.splitList;\n\n        var value = splitList['other'];\n\n        for (var i in splitList) {\n            if (count == i) {\n                value = splitList[i];\n                break;\n            }\n        }\n\n        return value;\n    };\n\n    /**\n     * 根据DataSet自动生成对应的splitList\n     */\n    Category.prototype.generateByDataSet = function (dataSet) {\n        var colors = [\n            'rgba(255, 255, 0, 0.8)',\n            'rgba(253, 98, 104, 0.8)',\n            'rgba(255, 146, 149, 0.8)',\n            'rgba(255, 241, 193, 0.8)',\n            'rgba(110, 176, 253, 0.8)',\n            'rgba(52, 139, 251, 0.8)',\n            'rgba(17, 102, 252, 0.8)',\n        ];\n        var data = dataSet.get();\n        this.splitList = {};\n        var count = 0;\n        for (var i = 0; i < data.length; i++) {\n            if (this.splitList[data[i].count] === undefined) {\n                this.splitList[data[i].count] = colors[count];\n                count++;\n            }\n            if (count >= colors.length - 1) {\n                break;\n            }\n        }\n\n        this.splitList['other'] = colors[colors.length - 1];\n    };\n\n    /**\n     * @author kyle / http://nikai.us/\n     */\n\n    /**\n     * Choropleth\n     * @param {Object} splitList:\n     *       [\n     *           {\n     *               start: 0,\n     *               end: 2,\n     *               value: randomColor()\n     *           },{\n     *               start: 2,\n     *               end: 4,\n     *               value: randomColor()\n     *           },{\n     *               start: 4,\n     *               value: randomColor()\n     *           }\n     *       ];\n     *\n     */\n    function Choropleth(splitList) {\n        this.splitList = splitList || [\n            {\n                start: 0,\n                value: 'red',\n            },\n        ];\n    }\n\n    Choropleth.prototype.get = function (count) {\n        var splitList = this.splitList;\n\n        var value = false;\n\n        for (var i = 0; i < splitList.length; i++) {\n            if (\n                (splitList[i].start === undefined ||\n                    (splitList[i].start !== undefined && count >= splitList[i].start)) &&\n                (splitList[i].end === undefined || (splitList[i].end !== undefined && count < splitList[i].end))\n            ) {\n                value = splitList[i].value;\n                break;\n            }\n        }\n\n        return value;\n    };\n\n    /**\n     * 根据DataSet自动生成对应的splitList\n     */\n    Choropleth.prototype.generateByDataSet = function (dataSet) {\n        var min = dataSet.getMin('count');\n        var max = dataSet.getMax('count');\n\n        this.generateByMinMax(min, max);\n    };\n\n    /**\n     * 根据DataSet自动生成对应的splitList\n     */\n    Choropleth.prototype.generateByMinMax = function (min, max) {\n        var colors = [\n            'rgba(255, 255, 0, 0.8)',\n            'rgba(253, 98, 104, 0.8)',\n            'rgba(255, 146, 149, 0.8)',\n            'rgba(255, 241, 193, 0.8)',\n            'rgba(110, 176, 253, 0.8)',\n            'rgba(52, 139, 251, 0.8)',\n            'rgba(17, 102, 252, 0.8)',\n        ];\n        var splitNum = (max - min) / 7;\n        var index = min;\n        this.splitList = [];\n        var count = 0;\n        while (index < max) {\n            this.splitList.push({\n                start: index,\n                end: index + splitNum,\n                value: colors[count],\n            });\n            count++;\n            index += splitNum;\n        }\n    };\n\n    /**\n     * @author Mofei<http://www.zhuwenlong.com>\n     */\n\n    var MapHelper = (function () {\n        function MapHelper(id, type, opt) {\n            classCallCheck(this, MapHelper);\n\n            if (!id || !type) {\n                console.warn('id 和 type 为必填项');\n                return false;\n            }\n\n            if (type == 'baidu') {\n                if (!BMap) {\n                    console.warn('请先引入百度地图JS API');\n                    return false;\n                }\n            } else {\n                console.warn('暂不支持你的地图类型');\n            }\n            this.type = type;\n            var center = opt && opt.center ? opt.center : [106.962497, 38.208726];\n            var zoom = opt && opt.zoom ? opt.zoom : 5;\n            var map = (this.map = new BMap.Map(id, {\n                enableMapClick: false,\n            }));\n            map.centerAndZoom(new BMap.Point(center[0], center[1]), zoom);\n            map.enableScrollWheelZoom(true);\n\n            map.setMapStyle({\n                style: 'light',\n            });\n        }\n\n        createClass(MapHelper, [\n            {\n                key: 'addLayer',\n                value: function addLayer(datas, options) {\n                    if (this.type == 'baidu') {\n                        return new mapv.baiduMapLayer(this.map, dataSet, options);\n                    }\n                },\n            },\n            {\n                key: 'getMap',\n                value: function getMap() {\n                    return this.map;\n                },\n            },\n        ]);\n        return MapHelper;\n    })();\n\n    /**\n     * 一直覆盖在当前地图视野的Canvas对象\n     *\n     * @author nikai (@胖嘟嘟的骨头, nikai@baidu.com)\n     *\n     * @param\n     * {\n     *     map 地图实例对象\n     * }\n     */\n\n    function CanvasLayer(options) {\n        this.options = options || {};\n        this.paneName = this.options.paneName || 'mapPane';\n        this.context = this.options.context || '2d';\n        this.zIndex = this.options.zIndex || 0;\n        this.mixBlendMode = this.options.mixBlendMode || null;\n        this.enableMassClear = this.options.enableMassClear;\n        this._map = options.map;\n        this._lastDrawTime = null;\n        this.show();\n    }\n\n    var global$3 = typeof window === 'undefined' ? {} : window;\n\n    if (global$3.BMap) {\n        CanvasLayer.prototype = new BMap.Overlay();\n\n        CanvasLayer.prototype.initialize = function (map) {\n            this._map = map;\n            var canvas = (this.canvas = document.createElement('canvas'));\n            canvas.style.cssText =\n                'position:absolute;' + 'left:0;' + 'top:0;' + 'z-index:' + this.zIndex + ';user-select:none;';\n            canvas.style.mixBlendMode = this.mixBlendMode;\n            this.adjustSize();\n            map.getPanes()[this.paneName].appendChild(canvas);\n            var that = this;\n            map.addEventListener('resize', function () {\n                that.adjustSize();\n                that._draw();\n            });\n            return this.canvas;\n        };\n\n        CanvasLayer.prototype.adjustSize = function () {\n            var size = this._map.getSize();\n            var canvas = this.canvas;\n\n            var devicePixelRatio = (this.devicePixelRatio = global$3.devicePixelRatio);\n\n            canvas.width = size.width * devicePixelRatio;\n            canvas.height = size.height * devicePixelRatio;\n            if (this.context == '2d') {\n                canvas.getContext(this.context).scale(devicePixelRatio, devicePixelRatio);\n            }\n\n            canvas.style.width = size.width + 'px';\n            canvas.style.height = size.height + 'px';\n        };\n\n        CanvasLayer.prototype.draw = function () {\n            var self = this;\n            clearTimeout(self.timeoutID);\n            self.timeoutID = setTimeout(function () {\n                self._draw();\n            }, 15);\n        };\n\n        CanvasLayer.prototype._draw = function () {\n            var map = this._map;\n            var size = map.getSize();\n            var center = map.getCenter();\n            if (center) {\n                var pixel = map.pointToOverlayPixel(center);\n                this.canvas.style.left = pixel.x - size.width / 2 + 'px';\n                this.canvas.style.top = pixel.y - size.height / 2 + 'px';\n                this.dispatchEvent('draw');\n                this.options.update && this.options.update.call(this);\n            }\n        };\n\n        CanvasLayer.prototype.getContainer = function () {\n            return this.canvas;\n        };\n\n        CanvasLayer.prototype.show = function () {\n            if (!this.canvas) {\n                this._map.addOverlay(this);\n            }\n            this.canvas.style.display = 'block';\n        };\n\n        CanvasLayer.prototype.hide = function () {\n            this.canvas.style.display = 'none';\n            //this._map.removeOverlay(this);\n        };\n\n        CanvasLayer.prototype.setZIndex = function (zIndex) {\n            this.canvas.style.zIndex = zIndex;\n        };\n\n        CanvasLayer.prototype.getZIndex = function () {\n            return this.zIndex;\n        };\n    }\n\n    /**\n     * Tween.js - Licensed under the MIT license\n     * https://github.com/tweenjs/tween.js\n     * ----------------------------------------------\n     *\n     * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n     * Thank you all, you're awesome!\n     */\n\n    var TWEEN =\n        TWEEN ||\n        (function () {\n            var _tweens = [];\n\n            return {\n                getAll: function getAll() {\n                    return _tweens;\n                },\n\n                removeAll: function removeAll() {\n                    _tweens = [];\n                },\n\n                add: function add(tween) {\n                    _tweens.push(tween);\n                },\n\n                remove: function remove(tween) {\n                    var i = _tweens.indexOf(tween);\n\n                    if (i !== -1) {\n                        _tweens.splice(i, 1);\n                    }\n                },\n\n                update: function update(time, preserve) {\n                    if (_tweens.length === 0) {\n                        return false;\n                    }\n\n                    var i = 0;\n\n                    time = time !== undefined ? time : TWEEN.now();\n\n                    while (i < _tweens.length) {\n                        if (_tweens[i].update(time) || preserve) {\n                            i++;\n                        } else {\n                            _tweens.splice(i, 1);\n                        }\n                    }\n\n                    return true;\n                },\n            };\n        })();\n\n    // Include a performance.now polyfill.\n    // In node.js, use process.hrtime.\n    if (typeof window === 'undefined' && typeof process !== 'undefined') {\n        TWEEN.now = function () {\n            var time = process.hrtime();\n\n            // Convert [seconds, nanoseconds] to milliseconds.\n            return time[0] * 1000 + time[1] / 1000000;\n        };\n    }\n    // In a browser, use window.performance.now if it is available.\n    else if (\n        typeof window !== 'undefined' &&\n        window.performance !== undefined &&\n        window.performance.now !== undefined\n    ) {\n        // This must be bound, because directly assigning this function\n        // leads to an invocation exception in Chrome.\n        TWEEN.now = window.performance.now.bind(window.performance);\n    }\n    // Use Date.now if it is available.\n    else if (Date.now !== undefined) {\n        TWEEN.now = Date.now;\n    }\n    // Otherwise, use 'new Date().getTime()'.\n    else {\n        TWEEN.now = function () {\n            return new Date().getTime();\n        };\n    }\n\n    TWEEN.Tween = function (object) {\n        var _object = object;\n        var _valuesStart = {};\n        var _valuesEnd = {};\n        var _valuesStartRepeat = {};\n        var _duration = 1000;\n        var _repeat = 0;\n        var _repeatDelayTime;\n        var _yoyo = false;\n        var _isPlaying = false;\n        var _reversed = false;\n        var _delayTime = 0;\n        var _startTime = null;\n        var _easingFunction = TWEEN.Easing.Linear.None;\n        var _interpolationFunction = TWEEN.Interpolation.Linear;\n        var _chainedTweens = [];\n        var _onStartCallback = null;\n        var _onStartCallbackFired = false;\n        var _onUpdateCallback = null;\n        var _onCompleteCallback = null;\n        var _onStopCallback = null;\n\n        this.to = function (properties, duration) {\n            _valuesEnd = properties;\n\n            if (duration !== undefined) {\n                _duration = duration;\n            }\n\n            return this;\n        };\n\n        this.start = function (time) {\n            TWEEN.add(this);\n\n            _isPlaying = true;\n\n            _onStartCallbackFired = false;\n\n            _startTime = time !== undefined ? time : TWEEN.now();\n            _startTime += _delayTime;\n\n            for (var property in _valuesEnd) {\n                // Check if an Array was provided as property value\n                if (_valuesEnd[property] instanceof Array) {\n                    if (_valuesEnd[property].length === 0) {\n                        continue;\n                    }\n\n                    // Create a local copy of the Array with the start value at the front\n                    _valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]);\n                }\n\n                // If `to()` specifies a property that doesn't exist in the source object,\n                // we should not set that property in the object\n                if (_object[property] === undefined) {\n                    continue;\n                }\n\n                // Save the starting value.\n                _valuesStart[property] = _object[property];\n\n                if (_valuesStart[property] instanceof Array === false) {\n                    _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n                }\n\n                _valuesStartRepeat[property] = _valuesStart[property] || 0;\n            }\n\n            return this;\n        };\n\n        this.stop = function () {\n            if (!_isPlaying) {\n                return this;\n            }\n\n            TWEEN.remove(this);\n            _isPlaying = false;\n\n            if (_onStopCallback !== null) {\n                _onStopCallback.call(_object, _object);\n            }\n\n            this.stopChainedTweens();\n            return this;\n        };\n\n        this.end = function () {\n            this.update(_startTime + _duration);\n            return this;\n        };\n\n        this.stopChainedTweens = function () {\n            for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {\n                _chainedTweens[i].stop();\n            }\n        };\n\n        this.delay = function (amount) {\n            _delayTime = amount;\n            return this;\n        };\n\n        this.repeat = function (times) {\n            _repeat = times;\n            return this;\n        };\n\n        this.repeatDelay = function (amount) {\n            _repeatDelayTime = amount;\n            return this;\n        };\n\n        this.yoyo = function (yoyo) {\n            _yoyo = yoyo;\n            return this;\n        };\n\n        this.easing = function (easing) {\n            _easingFunction = easing;\n            return this;\n        };\n\n        this.interpolation = function (interpolation) {\n            _interpolationFunction = interpolation;\n            return this;\n        };\n\n        this.chain = function () {\n            _chainedTweens = arguments;\n            return this;\n        };\n\n        this.onStart = function (callback) {\n            _onStartCallback = callback;\n            return this;\n        };\n\n        this.onUpdate = function (callback) {\n            _onUpdateCallback = callback;\n            return this;\n        };\n\n        this.onComplete = function (callback) {\n            _onCompleteCallback = callback;\n            return this;\n        };\n\n        this.onStop = function (callback) {\n            _onStopCallback = callback;\n            return this;\n        };\n\n        this.update = function (time) {\n            var property;\n            var elapsed;\n            var value;\n\n            if (time < _startTime) {\n                return true;\n            }\n\n            if (_onStartCallbackFired === false) {\n                if (_onStartCallback !== null) {\n                    _onStartCallback.call(_object, _object);\n                }\n\n                _onStartCallbackFired = true;\n            }\n\n            elapsed = (time - _startTime) / _duration;\n            elapsed = elapsed > 1 ? 1 : elapsed;\n\n            value = _easingFunction(elapsed);\n\n            for (property in _valuesEnd) {\n                // Don't update properties that do not exist in the source object\n                if (_valuesStart[property] === undefined) {\n                    continue;\n                }\n\n                var start = _valuesStart[property] || 0;\n                var end = _valuesEnd[property];\n\n                if (end instanceof Array) {\n                    _object[property] = _interpolationFunction(end, value);\n                } else {\n                    // Parses relative end values with start as base (e.g.: +10, -3)\n                    if (typeof end === 'string') {\n                        if (end.charAt(0) === '+' || end.charAt(0) === '-') {\n                            end = start + parseFloat(end);\n                        } else {\n                            end = parseFloat(end);\n                        }\n                    }\n\n                    // Protect against non numeric properties.\n                    if (typeof end === 'number') {\n                        _object[property] = start + (end - start) * value;\n                    }\n                }\n            }\n\n            if (_onUpdateCallback !== null) {\n                _onUpdateCallback.call(_object, value);\n            }\n\n            if (elapsed === 1) {\n                if (_repeat > 0) {\n                    if (isFinite(_repeat)) {\n                        _repeat--;\n                    }\n\n                    // Reassign starting values, restart by making startTime = now\n                    for (property in _valuesStartRepeat) {\n                        if (typeof _valuesEnd[property] === 'string') {\n                            _valuesStartRepeat[property] =\n                                _valuesStartRepeat[property] + parseFloat(_valuesEnd[property]);\n                        }\n\n                        if (_yoyo) {\n                            var tmp = _valuesStartRepeat[property];\n\n                            _valuesStartRepeat[property] = _valuesEnd[property];\n                            _valuesEnd[property] = tmp;\n                        }\n\n                        _valuesStart[property] = _valuesStartRepeat[property];\n                    }\n\n                    if (_yoyo) {\n                        _reversed = !_reversed;\n                    }\n\n                    if (_repeatDelayTime !== undefined) {\n                        _startTime = time + _repeatDelayTime;\n                    } else {\n                        _startTime = time + _delayTime;\n                    }\n\n                    return true;\n                } else {\n                    if (_onCompleteCallback !== null) {\n                        _onCompleteCallback.call(_object, _object);\n                    }\n\n                    for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {\n                        // Make the chained tweens start exactly at the time they should,\n                        // even if the `update()` method was called way past the duration of the tween\n                        _chainedTweens[i].start(_startTime + _duration);\n                    }\n\n                    return false;\n                }\n            }\n\n            return true;\n        };\n    };\n\n    TWEEN.Easing = {\n        Linear: {\n            None: function None(k) {\n                return k;\n            },\n        },\n\n        Quadratic: {\n            In: function In(k) {\n                return k * k;\n            },\n\n            Out: function Out(k) {\n                return k * (2 - k);\n            },\n\n            InOut: function InOut(k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k;\n                }\n\n                return -0.5 * (--k * (k - 2) - 1);\n            },\n        },\n\n        Cubic: {\n            In: function In(k) {\n                return k * k * k;\n            },\n\n            Out: function Out(k) {\n                return --k * k * k + 1;\n            },\n\n            InOut: function InOut(k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k * k;\n                }\n\n                return 0.5 * ((k -= 2) * k * k + 2);\n            },\n        },\n\n        Quartic: {\n            In: function In(k) {\n                return k * k * k * k;\n            },\n\n            Out: function Out(k) {\n                return 1 - --k * k * k * k;\n            },\n\n            InOut: function InOut(k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k * k * k;\n                }\n\n                return -0.5 * ((k -= 2) * k * k * k - 2);\n            },\n        },\n\n        Quintic: {\n            In: function In(k) {\n                return k * k * k * k * k;\n            },\n\n            Out: function Out(k) {\n                return --k * k * k * k * k + 1;\n            },\n\n            InOut: function InOut(k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k * k * k * k;\n                }\n\n                return 0.5 * ((k -= 2) * k * k * k * k + 2);\n            },\n        },\n\n        Sinusoidal: {\n            In: function In(k) {\n                return 1 - Math.cos((k * Math.PI) / 2);\n            },\n\n            Out: function Out(k) {\n                return Math.sin((k * Math.PI) / 2);\n            },\n\n            InOut: function InOut(k) {\n                return 0.5 * (1 - Math.cos(Math.PI * k));\n            },\n        },\n\n        Exponential: {\n            In: function In(k) {\n                return k === 0 ? 0 : Math.pow(1024, k - 1);\n            },\n\n            Out: function Out(k) {\n                return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n            },\n\n            InOut: function InOut(k) {\n                if (k === 0) {\n                    return 0;\n                }\n\n                if (k === 1) {\n                    return 1;\n                }\n\n                if ((k *= 2) < 1) {\n                    return 0.5 * Math.pow(1024, k - 1);\n                }\n\n                return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n            },\n        },\n\n        Circular: {\n            In: function In(k) {\n                return 1 - Math.sqrt(1 - k * k);\n            },\n\n            Out: function Out(k) {\n                return Math.sqrt(1 - --k * k);\n            },\n\n            InOut: function InOut(k) {\n                if ((k *= 2) < 1) {\n                    return -0.5 * (Math.sqrt(1 - k * k) - 1);\n                }\n\n                return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n            },\n        },\n\n        Elastic: {\n            In: function In(k) {\n                if (k === 0) {\n                    return 0;\n                }\n\n                if (k === 1) {\n                    return 1;\n                }\n\n                return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n            },\n\n            Out: function Out(k) {\n                if (k === 0) {\n                    return 0;\n                }\n\n                if (k === 1) {\n                    return 1;\n                }\n\n                return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;\n            },\n\n            InOut: function InOut(k) {\n                if (k === 0) {\n                    return 0;\n                }\n\n                if (k === 1) {\n                    return 1;\n                }\n\n                k *= 2;\n\n                if (k < 1) {\n                    return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n                }\n\n                return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;\n            },\n        },\n\n        Back: {\n            In: function In(k) {\n                var s = 1.70158;\n\n                return k * k * ((s + 1) * k - s);\n            },\n\n            Out: function Out(k) {\n                var s = 1.70158;\n\n                return --k * k * ((s + 1) * k + s) + 1;\n            },\n\n            InOut: function InOut(k) {\n                var s = 1.70158 * 1.525;\n\n                if ((k *= 2) < 1) {\n                    return 0.5 * (k * k * ((s + 1) * k - s));\n                }\n\n                return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n            },\n        },\n\n        Bounce: {\n            In: function In(k) {\n                return 1 - TWEEN.Easing.Bounce.Out(1 - k);\n            },\n\n            Out: function Out(k) {\n                if (k < 1 / 2.75) {\n                    return 7.5625 * k * k;\n                } else if (k < 2 / 2.75) {\n                    return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n                } else if (k < 2.5 / 2.75) {\n                    return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n                } else {\n                    return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n                }\n            },\n\n            InOut: function InOut(k) {\n                if (k < 0.5) {\n                    return TWEEN.Easing.Bounce.In(k * 2) * 0.5;\n                }\n\n                return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;\n            },\n        },\n    };\n\n    TWEEN.Interpolation = {\n        Linear: function Linear(v, k) {\n            var m = v.length - 1;\n            var f = m * k;\n            var i = Math.floor(f);\n            var fn = TWEEN.Interpolation.Utils.Linear;\n\n            if (k < 0) {\n                return fn(v[0], v[1], f);\n            }\n\n            if (k > 1) {\n                return fn(v[m], v[m - 1], m - f);\n            }\n\n            return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\n        },\n\n        Bezier: function Bezier(v, k) {\n            var b = 0;\n            var n = v.length - 1;\n            var pw = Math.pow;\n            var bn = TWEEN.Interpolation.Utils.Bernstein;\n\n            for (var i = 0; i <= n; i++) {\n                b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\n            }\n\n            return b;\n        },\n\n        CatmullRom: function CatmullRom(v, k) {\n            var m = v.length - 1;\n            var f = m * k;\n            var i = Math.floor(f);\n            var fn = TWEEN.Interpolation.Utils.CatmullRom;\n\n            if (v[0] === v[m]) {\n                if (k < 0) {\n                    i = Math.floor((f = m * (1 + k)));\n                }\n\n                return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n            } else {\n                if (k < 0) {\n                    return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\n                }\n\n                if (k > 1) {\n                    return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n                }\n\n                return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n            }\n        },\n\n        Utils: {\n            Linear: function Linear(p0, p1, t) {\n                return (p1 - p0) * t + p0;\n            },\n\n            Bernstein: function Bernstein(n, i) {\n                var fc = TWEEN.Interpolation.Utils.Factorial;\n\n                return fc(n) / fc(i) / fc(n - i);\n            },\n\n            Factorial: (function () {\n                var a = [1];\n\n                return function (n) {\n                    var s = 1;\n\n                    if (a[n]) {\n                        return a[n];\n                    }\n\n                    for (var i = n; i > 1; i--) {\n                        s *= i;\n                    }\n\n                    a[n] = s;\n                    return s;\n                };\n            })(),\n\n            CatmullRom: function CatmullRom(p0, p1, p2, p3, t) {\n                var v0 = (p2 - p0) * 0.5;\n                var v1 = (p3 - p1) * 0.5;\n                var t2 = t * t;\n                var t3 = t * t2;\n\n                return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n            },\n        },\n    };\n\n    /**\n     * @author Mofei Zhu<mapv@zhuwenlong.com>\n     * This file is to draw text\n     */\n\n    var drawText = {\n        draw: function draw(context, dataSet, options) {\n            var data = dataSet instanceof DataSet ? dataSet.get() : dataSet;\n            context.save();\n\n            // set from options\n            for (var key in options) {\n                context[key] = options[key];\n            }\n\n            var offset = options.offset || {\n                x: 0,\n                y: 0,\n            };\n\n            var rects = [];\n\n            var size = options._size || options.size;\n            if (size) {\n                context.font = 'bold ' + size + 'px Arial';\n            } else {\n                size = 12;\n            }\n\n            var textKey = options.textKey || 'text';\n\n            context.textAlign = 'center';\n            context.textBaseline = 'middle';\n\n            if (options.avoid) {\n                // 标注避让\n                for (var i = 0, len = data.length; i < len; i++) {\n                    var coordinates = data[i].geometry._coordinates || data[i].geometry.coordinates;\n                    var x = coordinates[0] + offset.x;\n                    var y = coordinates[1] + offset.y;\n                    var text = data[i][textKey];\n                    var textWidth = context.measureText(text).width;\n\n                    // 根据文本宽度和高度调整x，y位置，使得绘制文本时候坐标点在文本中心点，这个计算出的是左上角坐标\n                    var px = x - textWidth / 2;\n                    var py = y - size / 2;\n\n                    var rect = {\n                        sw: {\n                            x: px,\n                            y: py + size,\n                        },\n                        ne: {\n                            x: px + textWidth,\n                            y: py,\n                        },\n                    };\n\n                    if (!hasOverlay(rects, rect)) {\n                        rects.push(rect);\n                        px = px + textWidth / 2;\n                        py = py + size / 2;\n                        context.fillText(text, px, py);\n                    }\n                }\n            } else {\n                for (var i = 0, len = data.length; i < len; i++) {\n                    var coordinates = data[i].geometry._coordinates || data[i].geometry.coordinates;\n                    var x = coordinates[0] + offset.x;\n                    var y = coordinates[1] + offset.y;\n                    var text = data[i][textKey];\n                    context.fillText(text, x, y);\n                }\n            }\n\n            context.restore();\n        },\n    };\n\n    /*\n     *  当前文字区域和已有的文字区域是否有重叠部分\n     */\n    function hasOverlay(rects, overlay) {\n        for (var i = 0; i < rects.length; i++) {\n            if (isRectOverlay(rects[i], overlay)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    //判断2个矩形是否有重叠部分\n    function isRectOverlay(rect1, rect2) {\n        //minx、miny 2个矩形右下角最小的x和y\n        //maxx、maxy 2个矩形左上角最大的x和y\n        var minx = Math.min(rect1.ne.x, rect2.ne.x);\n        var miny = Math.min(rect1.sw.y, rect2.sw.y);\n        var maxx = Math.max(rect1.sw.x, rect2.sw.x);\n        var maxy = Math.max(rect1.ne.y, rect2.ne.y);\n        if (minx > maxx && miny > maxy) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @author Mofei Zhu<mapv@zhuwenlong.com>\n     * This file is to draw text\n     */\n\n    var drawIcon = {\n        draw: function draw(context, dataSet, options) {\n            var data = dataSet instanceof DataSet ? dataSet.get() : dataSet;\n\n            context.fillStyle = 'white';\n            context.textAlign = 'center';\n            context.textBaseline = 'middle';\n\n            var offset = options.offset || {\n                x: 0,\n                y: 0,\n            };\n\n            // set from options\n            // for (var key in options) {\n            //     context[key] = options[key];\n            // }\n            // console.log(data)\n            for (var i = 0, len = data.length; i < len; i++) {\n                if (data[i].geometry) {\n                    var deg = data[i].deg || options.deg;\n                    var icon = data[i].icon || options.icon;\n                    var coordinates = data[i].geometry._coordinates || data[i].geometry.coordinates;\n                    var x = coordinates[0];\n                    var y = coordinates[1];\n                    if (deg) {\n                        context.save();\n                        context.translate(x, y);\n                        context.rotate((deg * Math.PI) / 180);\n                        context.translate(-x, -y);\n                    }\n                    var width = options._width || options.width || icon.width;\n                    var height = options._height || options.height || icon.height;\n                    x = x - width / 2 + offset.x;\n                    y = y - height / 2 + offset.y;\n                    if (\n                        options.sx &&\n                        options.sy &&\n                        options.swidth &&\n                        options.sheight &&\n                        options.width &&\n                        options.height\n                    ) {\n                        context.drawImage(\n                            icon,\n                            options.sx,\n                            options.sy,\n                            options.swidth,\n                            options.sheight,\n                            x,\n                            y,\n                            width,\n                            height\n                        );\n                    } else if (options.width && options.height) {\n                        context.drawImage(icon, x, y, width, height);\n                    } else {\n                        context.drawImage(icon, x, y);\n                    }\n\n                    if (deg) {\n                        context.restore();\n                    }\n                }\n            }\n        },\n    };\n\n    /**\n     * @author kyle / http://nikai.us/\n     */\n\n    if (typeof window !== 'undefined') {\n        requestAnimationFrame(animate);\n    }\n\n    function animate(time) {\n        requestAnimationFrame(animate);\n        TWEEN.update(time);\n    }\n\n    var BaseLayer = (function () {\n        function BaseLayer(map, dataSet, options) {\n            classCallCheck(this, BaseLayer);\n\n            if (!(dataSet instanceof DataSet)) {\n                dataSet = new DataSet(dataSet);\n            }\n\n            this.dataSet = dataSet;\n            this.map = map;\n        }\n\n        createClass(BaseLayer, [\n            {\n                key: 'getDefaultContextConfig',\n                value: function getDefaultContextConfig() {\n                    return {\n                        globalAlpha: 1,\n                        globalCompositeOperation: 'source-over',\n                        imageSmoothingEnabled: true,\n                        strokeStyle: '#000000',\n                        fillStyle: '#000000',\n                        shadowOffsetX: 0,\n                        shadowOffsetY: 0,\n                        shadowBlur: 0,\n                        shadowColor: 'rgba(0, 0, 0, 0)',\n                        lineWidth: 1,\n                        lineCap: 'butt',\n                        lineJoin: 'miter',\n                        miterLimit: 10,\n                        lineDashOffset: 0,\n                        font: '10px sans-serif',\n                        textAlign: 'start',\n                        textBaseline: 'alphabetic',\n                    };\n                },\n            },\n            {\n                key: 'initDataRange',\n                value: function initDataRange(options) {\n                    var self = this;\n\n                    self.intensity = new Intensity({\n                        maxSize: self.options.maxSize,\n                        minSize: self.options.minSize,\n                        gradient: self.options.gradient,\n                        max: self.options.max || this.dataSet.getMax('count'),\n                    });\n\n                    self.category = new Category(self.options.splitList);\n                    self.choropleth = new Choropleth(self.options.splitList);\n                    if (self.options.splitList === undefined) {\n                        self.category.generateByDataSet(this.dataSet);\n                    }\n\n                    if (self.options.splitList === undefined) {\n                        var min = self.options.min || this.dataSet.getMin('count');\n                        var max = self.options.max || this.dataSet.getMax('count');\n                        self.choropleth.generateByMinMax(min, max);\n                    }\n                },\n            },\n            {\n                key: 'getLegend',\n                value: function getLegend(options) {\n                    var draw = this.options.draw;\n                    var legend = null;\n                    if (self.options.draw == 'intensity' || self.options.draw == 'heatmap') {\n                        return this.intensity.getLegend(options);\n                    }\n                },\n            },\n            {\n                key: 'processData',\n                value: function processData(data) {\n                    var self = this;\n                    var draw = self.options.draw;\n                    if (\n                        draw == 'bubble' ||\n                        draw == 'intensity' ||\n                        draw == 'category' ||\n                        draw == 'choropleth' ||\n                        draw == 'simple'\n                    ) {\n                        for (var i = 0; i < data.length; i++) {\n                            var item = data[i];\n\n                            if (self.options.draw == 'bubble') {\n                                data[i]._size = self.intensity.getSize(item.count);\n                            } else {\n                                data[i]._size = undefined;\n                            }\n\n                            var styleType = 'fillStyle';\n\n                            if (data[i].geometry.type === 'LineString' || self.options.styleType === 'stroke') {\n                                styleType = 'strokeStyle';\n                            }\n\n                            if (self.options.draw == 'intensity') {\n                                data[i][styleType] = self.intensity.getColor(item.count);\n                            } else if (self.options.draw == 'category') {\n                                data[i][styleType] = self.category.get(item.count);\n                            } else if (self.options.draw == 'choropleth') {\n                                data[i][styleType] = self.choropleth.get(item.count);\n                            }\n                        }\n                    }\n                },\n            },\n            {\n                key: 'isEnabledTime',\n                value: function isEnabledTime() {\n                    var animationOptions = this.options.animation;\n\n                    var flag = animationOptions && !(animationOptions.enabled === false);\n\n                    return flag;\n                },\n            },\n            {\n                key: 'argCheck',\n                value: function argCheck(options) {\n                    if (options.draw == 'heatmap') {\n                        if (options.strokeStyle) {\n                            console.warn(\n                                '[heatmap] options.strokeStyle is discard, pleause use options.strength [eg: options.strength = 0.1]'\n                            );\n                        }\n                    }\n                },\n            },\n            {\n                key: 'drawContext',\n                value: function drawContext(context, dataSet, options, nwPixel) {\n                    var self = this;\n                    switch (self.options.draw) {\n                        case 'heatmap':\n                            drawHeatmap.draw(context, dataSet, self.options);\n                            break;\n                        case 'grid':\n                        case 'honeycomb':\n                            self.options.offset = {\n                                x: nwPixel.x,\n                                y: nwPixel.y,\n                            };\n                            if (self.options.draw == 'grid') {\n                                drawGrid.draw(context, dataSet, self.options);\n                            } else {\n                                drawHoneycomb.draw(context, dataSet, self.options);\n                            }\n                            break;\n                        case 'text':\n                            drawText.draw(context, dataSet, self.options);\n                            break;\n                        case 'icon':\n                            drawIcon.draw(context, dataSet, self.options);\n                            break;\n                        case 'clip':\n                            context.save();\n                            context.fillStyle = self.options.fillStyle || 'rgba(0, 0, 0, 0.5)';\n                            context.fillRect(0, 0, context.canvas.width, context.canvas.height);\n                            drawSimple.draw(context, dataSet, self.options);\n                            context.beginPath();\n                            pathSimple.drawDataSet(context, dataSet, self.options);\n                            context.clip();\n                            clear(context);\n                            context.restore();\n                            break;\n                        default:\n                            if (self.options.context == 'webgl') {\n                                webglDrawSimple.draw(\n                                    self.canvasLayer.canvas.getContext('webgl'),\n                                    dataSet,\n                                    self.options\n                                );\n                            } else {\n                                drawSimple.draw(context, dataSet, self.options);\n                            }\n                    }\n                },\n            },\n            {\n                key: 'isPointInPath',\n                value: function isPointInPath(context, pixel) {\n                    var context = this.canvasLayer.canvas.getContext(this.context);\n                    var data = this.dataSet.get();\n                    for (var i = 0; i < data.length; i++) {\n                        context.beginPath();\n                        pathSimple.draw(context, data[i], this.options);\n                        if (\n                            context.isPointInPath(\n                                pixel.x * this.canvasLayer.devicePixelRatio,\n                                pixel.y * this.canvasLayer.devicePixelRatio\n                            )\n                        ) {\n                            return data[i];\n                        }\n                    }\n                },\n            },\n            {\n                key: 'clickEvent',\n                value: function clickEvent(pixel, e) {\n                    var dataItem = this.isPointInPath(this.getContext(), pixel);\n\n                    if (dataItem) {\n                        this.options.methods.click(dataItem, e);\n                    } else {\n                        this.options.methods.click(null, e);\n                    }\n                },\n            },\n            {\n                key: 'mousemoveEvent',\n                value: function mousemoveEvent(pixel, e) {\n                    var dataItem = this.isPointInPath(this.getContext(), pixel);\n                    if (dataItem) {\n                        this.options.methods.mousemove(dataItem, e);\n                    } else {\n                        this.options.methods.mousemove(null, e);\n                    }\n                },\n\n                /**\n                 * obj.options\n                 */\n            },\n            {\n                key: 'update',\n                value: function update(obj, isDraw) {\n                    var self = this;\n                    var _options = obj.options;\n                    var options = self.options;\n                    for (var i in _options) {\n                        options[i] = _options[i];\n                    }\n                    self.init(options);\n                    if (isDraw !== false) {\n                        self.draw();\n                    }\n                },\n            },\n            {\n                key: 'setOptions',\n                value: function setOptions(options) {\n                    var self = this;\n                    self.init(options);\n                    self.draw();\n                },\n            },\n            {\n                key: 'set',\n                value: function set$$1(obj) {\n                    var self = this;\n                    var ctx = this.getContext();\n                    var conf = this.getDefaultContextConfig();\n                    for (var i in conf) {\n                        ctx[i] = conf[i];\n                    }\n                    self.init(obj.options);\n                    self.draw();\n                },\n            },\n            {\n                key: 'destroy',\n                value: function destroy() {\n                    this.unbindEvent();\n                    this.hide();\n                },\n            },\n            {\n                key: 'initAnimator',\n                value: function initAnimator() {\n                    var self = this;\n                    var animationOptions = self.options.animation;\n\n                    if (self.options.draw == 'time' || self.isEnabledTime()) {\n                        if (!animationOptions.stepsRange) {\n                            animationOptions.stepsRange = {\n                                start: this.dataSet.getMin('time') || 0,\n                                end: this.dataSet.getMax('time') || 0,\n                            };\n                        }\n\n                        this.steps = {\n                            step: animationOptions.stepsRange.start,\n                        };\n                        self.animator = new TWEEN.Tween(this.steps)\n                            .onUpdate(function () {\n                                self._canvasUpdate(this.step);\n                            })\n                            .repeat(Infinity);\n\n                        this.addAnimatorEvent();\n\n                        var duration = animationOptions.duration * 1000 || 5000;\n\n                        self.animator.to(\n                            {\n                                step: animationOptions.stepsRange.end,\n                            },\n                            duration\n                        );\n                        self.animator.start();\n                    } else {\n                        self.animator && self.animator.stop();\n                    }\n                },\n            },\n            {\n                key: 'addAnimatorEvent',\n                value: function addAnimatorEvent() {},\n            },\n            {\n                key: 'animatorMovestartEvent',\n                value: function animatorMovestartEvent() {\n                    var animationOptions = this.options.animation;\n                    if (this.isEnabledTime() && this.animator) {\n                        this.steps.step = animationOptions.stepsRange.start;\n                        this.animator.stop();\n                    }\n                },\n            },\n            {\n                key: 'animatorMoveendEvent',\n                value: function animatorMoveendEvent() {\n                    if (this.isEnabledTime() && this.animator) {\n                        this.animator.start();\n                    }\n                },\n            },\n        ]);\n        return BaseLayer;\n    })();\n\n    var AnimationLayer = (function (_BaseLayer) {\n        inherits(AnimationLayer, _BaseLayer);\n\n        function AnimationLayer(map, dataSet, options) {\n            classCallCheck(this, AnimationLayer);\n\n            var _this = possibleConstructorReturn(\n                this,\n                (AnimationLayer.__proto__ || Object.getPrototypeOf(AnimationLayer)).call(this, map, dataSet, options)\n            );\n\n            _this.map = map;\n            _this.options = options || {};\n            _this.dataSet = dataSet;\n\n            _this.init(options);\n\n            var canvasLayer = new CanvasLayer({\n                map: map,\n                update: _this._canvasUpdate.bind(_this),\n            });\n            _this.transferToMercator();\n            var self = _this;\n            dataSet.on('change', function () {\n                self.transferToMercator();\n                canvasLayer.draw();\n            });\n            _this.ctx = canvasLayer.canvas.getContext('2d');\n\n            _this.start();\n            return _this;\n        }\n\n        createClass(AnimationLayer, [\n            {\n                key: 'init',\n                value: function init(options) {\n                    var self = this;\n                    self.options = options;\n                    this.initDataRange(options);\n                    this.context = self.options.context || '2d';\n\n                    if (self.options.zIndex) {\n                        this.canvasLayer && this.canvasLayer.setZIndex(self.options.zIndex);\n                    }\n\n                    if (self.options.max) {\n                        this.intensity.setMax(self.options.max);\n                    }\n\n                    if (self.options.min) {\n                        this.intensity.setMin(self.options.min);\n                    }\n\n                    this.initAnimator();\n                },\n\n                // 经纬度左边转换为墨卡托坐标\n            },\n            {\n                key: 'transferToMercator',\n                value: function transferToMercator() {\n                    var projection = this.map.getMapType().getProjection();\n\n                    if (this.options.coordType !== 'bd09mc') {\n                        var data = this.dataSet.get();\n                        data = this.dataSet.transferCoordinate(\n                            data,\n                            function (coordinates) {\n                                var pixel = projection.lngLatToPoint({\n                                    lng: coordinates[0],\n                                    lat: coordinates[1],\n                                });\n                                return [pixel.x, pixel.y];\n                            },\n                            'coordinates',\n                            'coordinates_mercator'\n                        );\n                        this.dataSet._set(data);\n                    }\n                },\n            },\n            {\n                key: '_canvasUpdate',\n                value: function _canvasUpdate() {\n                    var ctx = this.ctx;\n                    if (!ctx) {\n                        return;\n                    }\n                    //clear(ctx);\n                    var map = this.map;\n                    var zoomUnit = Math.pow(2, 18 - map.getZoom());\n                    var projection = map.getMapType().getProjection();\n\n                    var mcCenter = projection.lngLatToPoint(map.getCenter());\n                    var nwMc = new BMap.Pixel(\n                        mcCenter.x - (map.getSize().width / 2) * zoomUnit,\n                        mcCenter.y + (map.getSize().height / 2) * zoomUnit\n                    ); //左上角墨卡托坐标\n\n                    clear(ctx);\n\n                    var dataGetOptions = {\n                        fromColumn: this.options.coordType == 'bd09mc' ? 'coordinates' : 'coordinates_mercator',\n                        transferCoordinate: function transferCoordinate(coordinate) {\n                            if (!coordinate) {\n                                return;\n                            }\n                            var x = (coordinate[0] - nwMc.x) / zoomUnit;\n                            var y = (nwMc.y - coordinate[1]) / zoomUnit;\n                            return [x, y];\n                        },\n                    };\n\n                    this.data = this.dataSet.get(dataGetOptions);\n\n                    this.processData(this.data);\n\n                    this.drawAnimation();\n                },\n            },\n            {\n                key: 'drawAnimation',\n                value: function drawAnimation() {\n                    var ctx = this.ctx;\n                    var data = this.data;\n                    if (!data) {\n                        return;\n                    }\n\n                    ctx.save();\n                    ctx.globalCompositeOperation = 'destination-out';\n                    ctx.fillStyle = 'rgba(0, 0, 0, .1)';\n                    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n                    ctx.restore();\n\n                    ctx.save();\n                    if (this.options.shadowColor) {\n                        ctx.shadowColor = this.options.shadowColor;\n                    }\n\n                    if (this.options.shadowBlur) {\n                        ctx.shadowBlur = this.options.shadowBlur;\n                    }\n\n                    if (this.options.globalAlpha) {\n                        ctx.globalAlpha = this.options.globalAlpha;\n                    }\n\n                    if (this.options.globalCompositeOperation) {\n                        ctx.globalCompositeOperation = this.options.globalCompositeOperation;\n                    }\n\n                    var options = this.options;\n                    for (var i = 0; i < data.length; i++) {\n                        if (data[i].geometry.type === 'Point') {\n                            ctx.beginPath();\n                            var maxSize = data[i].size || this.options.size;\n                            var minSize = data[i].minSize || this.options.minSize || 0;\n                            if (data[i]._size === undefined) {\n                                data[i]._size = minSize;\n                            }\n                            ctx.arc(\n                                data[i].geometry._coordinates[0],\n                                data[i].geometry._coordinates[1],\n                                data[i]._size,\n                                0,\n                                Math.PI * 2,\n                                true\n                            );\n                            ctx.closePath();\n\n                            data[i]._size++;\n\n                            if (data[i]._size > maxSize) {\n                                data[i]._size = minSize;\n                            }\n                            ctx.lineWidth = 1;\n                            ctx.strokeStyle = data[i].strokeStyle || options.strokeStyle || 'yellow';\n                            ctx.stroke();\n                            var fillStyle = data[i].fillStyle || options.fillStyle;\n                            if (fillStyle) {\n                                ctx.fillStyle = fillStyle;\n                                ctx.fill();\n                            }\n                        } else if (data[i].geometry.type === 'LineString') {\n                            ctx.beginPath();\n                            var size = data[i].size || this.options.size || 5;\n                            var minSize = data[i].minSize || this.options.minSize || 0;\n                            if (data[i]._index === undefined) {\n                                data[i]._index = 0;\n                            }\n                            var index = data[i]._index;\n                            ctx.arc(\n                                data[i].geometry._coordinates[index][0],\n                                data[i].geometry._coordinates[index][1],\n                                size,\n                                0,\n                                Math.PI * 2,\n                                true\n                            );\n                            ctx.closePath();\n\n                            data[i]._index++;\n\n                            if (data[i]._index >= data[i].geometry._coordinates.length) {\n                                data[i]._index = 0;\n                            }\n\n                            ctx.lineWidth = options.lineWidth || 1;\n                            var strokeStyle = data[i].strokeStyle || options.strokeStyle;\n                            var fillStyle = data[i].fillStyle || options.fillStyle || 'yellow';\n                            ctx.fillStyle = fillStyle;\n                            ctx.fill();\n                            if (strokeStyle) {\n                                ctx.strokeStyle = strokeStyle;\n                                ctx.stroke();\n                            }\n                        }\n                    }\n                    ctx.restore();\n                },\n            },\n            {\n                key: 'animate',\n                value: function animate() {\n                    this.drawAnimation();\n                    var animateTime = this.options.animateTime || 100;\n                    this.timeout = setTimeout(this.animate.bind(this), animateTime);\n                },\n            },\n            {\n                key: 'start',\n                value: function start() {\n                    this.stop();\n                    this.animate();\n                },\n            },\n            {\n                key: 'stop',\n                value: function stop() {\n                    clearTimeout(this.timeout);\n                },\n            },\n        ]);\n        return AnimationLayer;\n    })(BaseLayer);\n\n    /**\n     * @author kyle / http://nikai.us/\n     */\n\n    var Layer = (function (_BaseLayer) {\n        inherits(Layer, _BaseLayer);\n\n        function Layer(map, dataSet, options) {\n            classCallCheck(this, Layer);\n\n            var _this = possibleConstructorReturn(\n                this,\n                (Layer.__proto__ || Object.getPrototypeOf(Layer)).call(this, map, dataSet, options)\n            );\n\n            var self = _this;\n            var data = null;\n            options = options || {};\n\n            self.init(options);\n            self.argCheck(options);\n            self.transferToMercator();\n\n            var canvasLayer = (_this.canvasLayer = new CanvasLayer({\n                map: map,\n                context: _this.context,\n                paneName: options.paneName,\n                mixBlendMode: options.mixBlendMode,\n                enableMassClear: options.enableMassClear,\n                zIndex: options.zIndex,\n                update: function update() {\n                    self._canvasUpdate();\n                },\n            }));\n\n            dataSet.on('change', function () {\n                self.transferToMercator();\n                canvasLayer.draw();\n            });\n\n            _this.clickEvent = _this.clickEvent.bind(_this);\n            _this.mousemoveEvent = _this.mousemoveEvent.bind(_this);\n            _this.bindEvent();\n\n            return _this;\n        }\n\n        createClass(Layer, [\n            {\n                key: 'clickEvent',\n                value: function clickEvent(e) {\n                    var pixel = e.pixel;\n                    get(Layer.prototype.__proto__ || Object.getPrototypeOf(Layer.prototype), 'clickEvent', this).call(\n                        this,\n                        pixel,\n                        e\n                    );\n                },\n            },\n            {\n                key: 'mousemoveEvent',\n                value: function mousemoveEvent(e) {\n                    var pixel = e.pixel;\n                    get(\n                        Layer.prototype.__proto__ || Object.getPrototypeOf(Layer.prototype),\n                        'mousemoveEvent',\n                        this\n                    ).call(this, pixel, e);\n                },\n            },\n            {\n                key: 'bindEvent',\n                value: function bindEvent(e) {\n                    var map = this.map;\n\n                    if (this.options.methods) {\n                        if (this.options.methods.click) {\n                            map.setDefaultCursor('default');\n                            map.addEventListener('click', this.clickEvent);\n                        }\n                        if (this.options.methods.mousemove) {\n                            map.addEventListener('mousemove', this.mousemoveEvent);\n                        }\n                    }\n                },\n            },\n            {\n                key: 'unbindEvent',\n                value: function unbindEvent(e) {\n                    var map = this.map;\n\n                    if (this.options.methods) {\n                        if (this.options.methods.click) {\n                            map.removeEventListener('click', this.clickEvent);\n                        }\n                        if (this.options.methods.mousemove) {\n                            map.removeEventListener('mousemove', this.mousemoveEvent);\n                        }\n                    }\n                },\n\n                // 经纬度左边转换为墨卡托坐标\n            },\n            {\n                key: 'transferToMercator',\n                value: function transferToMercator() {\n                    var projection = this.map.getMapType().getProjection();\n\n                    if (this.options.coordType !== 'bd09mc') {\n                        var data = this.dataSet.get();\n                        data = this.dataSet.transferCoordinate(\n                            data,\n                            function (coordinates) {\n                                var pixel = projection.lngLatToPoint({\n                                    lng: coordinates[0],\n                                    lat: coordinates[1],\n                                });\n                                return [pixel.x, pixel.y];\n                            },\n                            'coordinates',\n                            'coordinates_mercator'\n                        );\n                        this.dataSet._set(data);\n                    }\n                },\n            },\n            {\n                key: 'getContext',\n                value: function getContext() {\n                    return this.canvasLayer.canvas.getContext(this.context);\n                },\n            },\n            {\n                key: '_canvasUpdate',\n                value: function _canvasUpdate(time) {\n                    if (!this.canvasLayer) {\n                        return;\n                    }\n\n                    var self = this;\n\n                    var animationOptions = self.options.animation;\n\n                    var map = this.canvasLayer._map;\n\n                    var zoomUnit = Math.pow(2, 18 - map.getZoom());\n                    var projection = map.getMapType().getProjection();\n\n                    var mcCenter = projection.lngLatToPoint(map.getCenter());\n                    var nwMc = new BMap.Pixel(\n                        mcCenter.x - (map.getSize().width / 2) * zoomUnit,\n                        mcCenter.y + (map.getSize().height / 2) * zoomUnit\n                    ); //左上角墨卡托坐标\n\n                    var context = this.getContext();\n\n                    if (self.isEnabledTime()) {\n                        if (time === undefined) {\n                            clear(context);\n                            return;\n                        }\n                        if (this.context == '2d') {\n                            context.save();\n                            context.globalCompositeOperation = 'destination-out';\n                            context.fillStyle = 'rgba(0, 0, 0, .1)';\n                            context.fillRect(0, 0, context.canvas.width, context.canvas.height);\n                            context.restore();\n                        }\n                    } else {\n                        clear(context);\n                    }\n\n                    if (this.context == '2d') {\n                        for (var key in self.options) {\n                            context[key] = self.options[key];\n                        }\n                    } else {\n                        context.clear(context.COLOR_BUFFER_BIT);\n                    }\n\n                    if (\n                        (self.options.minZoom && map.getZoom() < self.options.minZoom) ||\n                        (self.options.maxZoom && map.getZoom() > self.options.maxZoom)\n                    ) {\n                        return;\n                    }\n\n                    var scale = 1;\n                    if (this.context != '2d') {\n                        scale = this.canvasLayer.devicePixelRatio;\n                    }\n\n                    var dataGetOptions = {\n                        fromColumn: self.options.coordType == 'bd09mc' ? 'coordinates' : 'coordinates_mercator',\n                        transferCoordinate: function transferCoordinate(coordinate) {\n                            var x = ((coordinate[0] - nwMc.x) / zoomUnit) * scale;\n                            var y = ((nwMc.y - coordinate[1]) / zoomUnit) * scale;\n                            return [x, y];\n                        },\n                    };\n\n                    if (time !== undefined) {\n                        dataGetOptions.filter = function (item) {\n                            var trails = animationOptions.trails || 10;\n                            if (time && item.time > time - trails && item.time < time) {\n                                return true;\n                            } else {\n                                return false;\n                            }\n                        };\n                    }\n\n                    // get data from data set\n                    var data = self.dataSet.get(dataGetOptions);\n\n                    this.processData(data);\n\n                    var nwPixel = map.pointToPixel(new BMap.Point(0, 0));\n\n                    if (self.options.unit == 'm') {\n                        if (self.options.size) {\n                            self.options._size = self.options.size / zoomUnit;\n                        }\n                        if (self.options.width) {\n                            self.options._width = self.options.width / zoomUnit;\n                        }\n                        if (self.options.height) {\n                            self.options._height = self.options.height / zoomUnit;\n                        }\n                    } else {\n                        self.options._size = self.options.size;\n                        self.options._height = self.options.height;\n                        self.options._width = self.options.width;\n                    }\n\n                    this.drawContext(context, data, self.options, nwPixel);\n\n                    //console.timeEnd('draw');\n\n                    //console.timeEnd('update')\n                    self.options.updateCallback && self.options.updateCallback(time);\n                },\n            },\n            {\n                key: 'init',\n                value: function init(options) {\n                    var self = this;\n                    self.options = options;\n                    this.initDataRange(options);\n                    this.context = self.options.context || '2d';\n\n                    if (self.options.zIndex) {\n                        this.canvasLayer && this.canvasLayer.setZIndex(self.options.zIndex);\n                    }\n\n                    if (self.options.max) {\n                        this.intensity.setMax(self.options.max);\n                    }\n\n                    if (self.options.min) {\n                        this.intensity.setMin(self.options.min);\n                    }\n\n                    this.initAnimator();\n                },\n            },\n            {\n                key: 'addAnimatorEvent',\n                value: function addAnimatorEvent() {\n                    this.map.addEventListener('movestart', this.animatorMovestartEvent.bind(this));\n                    this.map.addEventListener('moveend', this.animatorMoveendEvent.bind(this));\n                },\n            },\n            {\n                key: 'show',\n                value: function show() {\n                    this.map.addOverlay(this.canvasLayer);\n                },\n            },\n            {\n                key: 'hide',\n                value: function hide() {\n                    this.map.removeOverlay(this.canvasLayer);\n                },\n            },\n            {\n                key: 'draw',\n                value: function draw() {\n                    this.canvasLayer.draw();\n                },\n            },\n        ]);\n        return Layer;\n    })(BaseLayer);\n\n    /**\n     * Copyright 2012 Google Inc. All Rights Reserved.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *     http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n\n    /**\n     * @fileoverview Extends OverlayView to provide a canvas \"Layer\".\n     * @author Brendan Kenny\n     */\n\n    /**\n     * A map layer that provides a canvas over the slippy map and a callback\n     * system for efficient animation. Requires canvas and CSS 2D transform\n     * support.\n     * @constructor\n     * @extends google.maps.OverlayView\n     * @param {CanvasLayerOptions=} opt_options Options to set in this CanvasLayer.\n     */\n    function CanvasLayer$2(opt_options) {\n        /**\n         * If true, canvas is in a map pane and the OverlayView is fully functional.\n         * See google.maps.OverlayView.onAdd for more information.\n         * @type {boolean}\n         * @private\n         */\n        this.isAdded_ = false;\n\n        /**\n         * If true, each update will immediately schedule the next.\n         * @type {boolean}\n         * @private\n         */\n        this.isAnimated_ = false;\n\n        /**\n         * The name of the MapPane in which this layer will be displayed.\n         * @type {string}\n         * @private\n         */\n        this.paneName_ = CanvasLayer$2.DEFAULT_PANE_NAME_;\n\n        /**\n         * A user-supplied function called whenever an update is required. Null or\n         * undefined if a callback is not provided.\n         * @type {?function=}\n         * @private\n         */\n        this.updateHandler_ = null;\n\n        /**\n         * A user-supplied function called whenever an update is required and the\n         * map has been resized since the last update. Null or undefined if a\n         * callback is not provided.\n         * @type {?function}\n         * @private\n         */\n        this.resizeHandler_ = null;\n\n        /**\n         * The LatLng coordinate of the top left of the current view of the map. Will\n         * be null when this.isAdded_ is false.\n         * @type {google.maps.LatLng}\n         * @private\n         */\n        this.topLeft_ = null;\n\n        /**\n         * The map-pan event listener. Will be null when this.isAdded_ is false. Will\n         * be null when this.isAdded_ is false.\n         * @type {?function}\n         * @private\n         */\n        this.centerListener_ = null;\n\n        /**\n         * The map-resize event listener. Will be null when this.isAdded_ is false.\n         * @type {?function}\n         * @private\n         */\n        this.resizeListener_ = null;\n\n        /**\n         * If true, the map size has changed and this.resizeHandler_ must be called\n         * on the next update.\n         * @type {boolean}\n         * @private\n         */\n        this.needsResize_ = true;\n\n        /**\n         * A browser-defined id for the currently requested callback. Null when no\n         * callback is queued.\n         * @type {?number}\n         * @private\n         */\n        this.requestAnimationFrameId_ = null;\n\n        var canvas = document.createElement('canvas');\n        canvas.style.position = 'absolute';\n        canvas.style.top = 0;\n        canvas.style.left = 0;\n        canvas.style.pointerEvents = 'none';\n\n        /**\n         * The canvas element.\n         * @type {!HTMLCanvasElement}\n         */\n        this.canvas = canvas;\n\n        /**\n         * The CSS width of the canvas, which may be different than the width of the\n         * backing store.\n         * @private {number}\n         */\n        this.canvasCssWidth_ = 300;\n\n        /**\n         * The CSS height of the canvas, which may be different than the height of\n         * the backing store.\n         * @private {number}\n         */\n        this.canvasCssHeight_ = 150;\n\n        /**\n         * A value for scaling the CanvasLayer resolution relative to the CanvasLayer\n         * display size.\n         * @private {number}\n         */\n        this.resolutionScale_ = 1;\n\n        /**\n         * Simple bind for functions with no args for bind-less browsers (Safari).\n         * @param {Object} thisArg The this value used for the target function.\n         * @param {function} func The function to be bound.\n         */\n        function simpleBindShim(thisArg, func) {\n            return function () {\n                func.apply(thisArg);\n            };\n        }\n\n        /**\n         * A reference to this.repositionCanvas_ with this bound as its this value.\n         * @type {function}\n         * @private\n         */\n        this.repositionFunction_ = simpleBindShim(this, this.repositionCanvas_);\n\n        /**\n         * A reference to this.resize_ with this bound as its this value.\n         * @type {function}\n         * @private\n         */\n        this.resizeFunction_ = simpleBindShim(this, this.resize_);\n\n        /**\n         * A reference to this.update_ with this bound as its this value.\n         * @type {function}\n         * @private\n         */\n        this.requestUpdateFunction_ = simpleBindShim(this, this.update_);\n\n        // set provided options, if any\n        if (opt_options) {\n            this.setOptions(opt_options);\n        }\n    }\n\n    var global$4 = typeof window === 'undefined' ? {} : window;\n\n    if (global$4.google && global$4.google.maps) {\n        CanvasLayer$2.prototype = new google.maps.OverlayView();\n\n        /**\n         * The default MapPane to contain the canvas.\n         * @type {string}\n         * @const\n         * @private\n         */\n        CanvasLayer$2.DEFAULT_PANE_NAME_ = 'overlayLayer';\n\n        /**\n         * Transform CSS property name, with vendor prefix if required. If browser\n         * does not support transforms, property will be ignored.\n         * @type {string}\n         * @const\n         * @private\n         */\n        CanvasLayer$2.CSS_TRANSFORM_ = (function () {\n            var div = document.createElement('div');\n            var transformProps = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'msTransform'];\n            for (var i = 0; i < transformProps.length; i++) {\n                var prop = transformProps[i];\n                if (div.style[prop] !== undefined) {\n                    return prop;\n                }\n            }\n\n            // return unprefixed version by default\n            return transformProps[0];\n        })();\n\n        /**\n         * The requestAnimationFrame function, with vendor-prefixed or setTimeout-based\n         * fallbacks. MUST be called with window as thisArg.\n         * @type {function}\n         * @param {function} callback The function to add to the frame request queue.\n         * @return {number} The browser-defined id for the requested callback.\n         * @private\n         */\n        CanvasLayer$2.prototype.requestAnimFrame_ =\n            global$4.requestAnimationFrame ||\n            global$4.webkitRequestAnimationFrame ||\n            global$4.mozRequestAnimationFrame ||\n            global$4.oRequestAnimationFrame ||\n            global$4.msRequestAnimationFrame ||\n            function (callback) {\n                return global$4.setTimeout(callback, 1000 / 60);\n            };\n\n        /**\n         * The cancelAnimationFrame function, with vendor-prefixed fallback. Does not\n         * fall back to clearTimeout as some platforms implement requestAnimationFrame\n         * but not cancelAnimationFrame, and the cost is an extra frame on onRemove.\n         * MUST be called with window as thisArg.\n         * @type {function}\n         * @param {number=} requestId The id of the frame request to cancel.\n         * @private\n         */\n        CanvasLayer$2.prototype.cancelAnimFrame_ =\n            global$4.cancelAnimationFrame ||\n            global$4.webkitCancelAnimationFrame ||\n            global$4.mozCancelAnimationFrame ||\n            global$4.oCancelAnimationFrame ||\n            global$4.msCancelAnimationFrame ||\n            function (requestId) {};\n\n        /**\n         * Sets any options provided. See CanvasLayerOptions for more information.\n         * @param {CanvasLayerOptions} options The options to set.\n         */\n        CanvasLayer$2.prototype.setOptions = function (options) {\n            if (options.animate !== undefined) {\n                this.setAnimate(options.animate);\n            }\n\n            if (options.paneName !== undefined) {\n                this.setPaneName(options.paneName);\n            }\n\n            if (options.updateHandler !== undefined) {\n                this.setUpdateHandler(options.updateHandler);\n            }\n\n            if (options.resizeHandler !== undefined) {\n                this.setResizeHandler(options.resizeHandler);\n            }\n\n            if (options.resolutionScale !== undefined) {\n                this.setResolutionScale(options.resolutionScale);\n            }\n\n            if (options.map !== undefined) {\n                this.setMap(options.map);\n            }\n        };\n\n        /**\n         * Set the animated state of the layer. If true, updateHandler will be called\n         * repeatedly, once per frame. If false, updateHandler will only be called when\n         * a map property changes that could require the canvas content to be redrawn.\n         * @param {boolean} animate Whether the canvas is animated.\n         */\n        CanvasLayer$2.prototype.setAnimate = function (animate) {\n            this.isAnimated_ = !!animate;\n\n            if (this.isAnimated_) {\n                this.scheduleUpdate();\n            }\n        };\n\n        /**\n         * @return {boolean} Whether the canvas is animated.\n         */\n        CanvasLayer$2.prototype.isAnimated = function () {\n            return this.isAnimated_;\n        };\n\n        /**\n         * Set the MapPane in which this layer will be displayed, by name. See\n         * {@code google.maps.MapPanes} for the panes available.\n         * @param {string} paneName The name of the desired MapPane.\n         */\n        CanvasLayer$2.prototype.setPaneName = function (paneName) {\n            this.paneName_ = paneName;\n\n            this.setPane_();\n        };\n\n        /**\n         * @return {string} The name of the current container pane.\n         */\n        CanvasLayer$2.prototype.getPaneName = function () {\n            return this.paneName_;\n        };\n\n        /**\n         * Adds the canvas to the specified container pane. Since this is guaranteed to\n         * execute only after onAdd is called, this is when paneName's existence is\n         * checked (and an error is thrown if it doesn't exist).\n         * @private\n         */\n        CanvasLayer$2.prototype.setPane_ = function () {\n            if (!this.isAdded_) {\n                return;\n            }\n\n            // onAdd has been called, so panes can be used\n            var panes = this.getPanes();\n            if (!panes[this.paneName_]) {\n                throw new Error('\"' + this.paneName_ + '\" is not a valid MapPane name.');\n            }\n\n            panes[this.paneName_].appendChild(this.canvas);\n        };\n\n        /**\n         * Set a function that will be called whenever the parent map and the overlay's\n         * canvas have been resized. If opt_resizeHandler is null or unspecified, any\n         * existing callback is removed.\n         * @param {?function=} opt_resizeHandler The resize callback function.\n         */\n        CanvasLayer$2.prototype.setResizeHandler = function (opt_resizeHandler) {\n            this.resizeHandler_ = opt_resizeHandler;\n        };\n\n        /**\n         * Sets a value for scaling the canvas resolution relative to the canvas\n         * display size. This can be used to save computation by scaling the backing\n         * buffer down, or to support high DPI devices by scaling it up (by e.g.\n         * window.devicePixelRatio).\n         * @param {number} scale\n         */\n        CanvasLayer$2.prototype.setResolutionScale = function (scale) {\n            if (typeof scale === 'number') {\n                this.resolutionScale_ = scale;\n                this.resize_();\n            }\n        };\n\n        /**\n         * Set a function that will be called when a repaint of the canvas is required.\n         * If opt_updateHandler is null or unspecified, any existing callback is\n         * removed.\n         * @param {?function=} opt_updateHandler The update callback function.\n         */\n        CanvasLayer$2.prototype.setUpdateHandler = function (opt_updateHandler) {\n            this.updateHandler_ = opt_updateHandler;\n        };\n\n        /**\n         * @inheritDoc\n         */\n        CanvasLayer$2.prototype.onAdd = function () {\n            if (this.isAdded_) {\n                return;\n            }\n\n            this.isAdded_ = true;\n            this.setPane_();\n\n            this.resizeListener_ = google.maps.event.addListener(this.getMap(), 'resize', this.resizeFunction_);\n            this.centerListener_ = google.maps.event.addListener(\n                this.getMap(),\n                'center_changed',\n                this.repositionFunction_\n            );\n\n            this.resize_();\n            this.repositionCanvas_();\n        };\n\n        /**\n         * @inheritDoc\n         */\n        CanvasLayer$2.prototype.onRemove = function () {\n            if (!this.isAdded_) {\n                return;\n            }\n\n            this.isAdded_ = false;\n            this.topLeft_ = null;\n\n            // remove canvas and listeners for pan and resize from map\n            this.canvas.parentElement.removeChild(this.canvas);\n            if (this.centerListener_) {\n                google.maps.event.removeListener(this.centerListener_);\n                this.centerListener_ = null;\n            }\n            if (this.resizeListener_) {\n                google.maps.event.removeListener(this.resizeListener_);\n                this.resizeListener_ = null;\n            }\n\n            // cease canvas update callbacks\n            if (this.requestAnimationFrameId_) {\n                this.cancelAnimFrame_.call(global$4, this.requestAnimationFrameId_);\n                this.requestAnimationFrameId_ = null;\n            }\n        };\n\n        /**\n         * The internal callback for resize events that resizes the canvas to keep the\n         * map properly covered.\n         * @private\n         */\n        CanvasLayer$2.prototype.resize_ = function () {\n            if (!this.isAdded_) {\n                return;\n            }\n\n            var map = this.getMap();\n            var mapWidth = map.getDiv().offsetWidth;\n            var mapHeight = map.getDiv().offsetHeight;\n\n            var newWidth = mapWidth * this.resolutionScale_;\n            var newHeight = mapHeight * this.resolutionScale_;\n            var oldWidth = this.canvas.width;\n            var oldHeight = this.canvas.height;\n\n            // resizing may allocate a new back buffer, so do so conservatively\n            if (oldWidth !== newWidth || oldHeight !== newHeight) {\n                this.canvas.width = newWidth;\n                this.canvas.height = newHeight;\n\n                this.needsResize_ = true;\n                this.scheduleUpdate();\n            }\n\n            // reset styling if new sizes don't match; resize of data not needed\n            if (this.canvasCssWidth_ !== mapWidth || this.canvasCssHeight_ !== mapHeight) {\n                this.canvasCssWidth_ = mapWidth;\n                this.canvasCssHeight_ = mapHeight;\n                this.canvas.style.width = mapWidth + 'px';\n                this.canvas.style.height = mapHeight + 'px';\n            }\n        };\n\n        /**\n         * @inheritDoc\n         */\n        CanvasLayer$2.prototype.draw = function () {\n            this.repositionCanvas_();\n        };\n\n        /**\n         * Internal callback for map view changes. Since the Maps API moves the overlay\n         * along with the map, this function calculates the opposite translation to\n         * keep the canvas in place.\n         * @private\n         */\n        CanvasLayer$2.prototype.repositionCanvas_ = function () {\n            // TODO(bckenny): *should* only be executed on RAF, but in current browsers\n            //     this causes noticeable hitches in map and overlay relative\n            //     positioning.\n\n            var map = this.getMap();\n\n            // topLeft can't be calculated from map.getBounds(), because bounds are\n            // clamped to -180 and 180 when completely zoomed out. Instead, calculate\n            // left as an offset from the center, which is an unwrapped LatLng.\n            var top = map.getBounds().getNorthEast().lat();\n            var center = map.getCenter();\n            var scale = Math.pow(2, map.getZoom());\n            var left = center.lng() - (this.canvasCssWidth_ * 180) / (256 * scale);\n            this.topLeft_ = new google.maps.LatLng(top, left);\n\n            // Canvas position relative to draggable map's container depends on\n            // overlayView's projection, not the map's. Have to use the center of the\n            // map for this, not the top left, for the same reason as above.\n            var projection = this.getProjection();\n            var divCenter = projection.fromLatLngToDivPixel(center);\n            var offsetX = -Math.round(this.canvasCssWidth_ / 2 - divCenter.x);\n            var offsetY = -Math.round(this.canvasCssHeight_ / 2 - divCenter.y);\n            this.canvas.style[CanvasLayer$2.CSS_TRANSFORM_] = 'translate(' + offsetX + 'px,' + offsetY + 'px)';\n\n            this.scheduleUpdate();\n        };\n\n        /**\n         * Internal callback that serves as main animation scheduler via\n         * requestAnimationFrame. Calls resize and update callbacks if set, and\n         * schedules the next frame if overlay is animated.\n         * @private\n         */\n        CanvasLayer$2.prototype.update_ = function () {\n            this.requestAnimationFrameId_ = null;\n\n            if (!this.isAdded_) {\n                return;\n            }\n\n            if (this.isAnimated_) {\n                this.scheduleUpdate();\n            }\n\n            if (this.needsResize_ && this.resizeHandler_) {\n                this.needsResize_ = false;\n                this.resizeHandler_();\n            }\n\n            if (this.updateHandler_) {\n                this.updateHandler_();\n            }\n        };\n\n        /**\n         * A convenience method to get the current LatLng coordinate of the top left of\n         * the current view of the map.\n         * @return {google.maps.LatLng} The top left coordinate.\n         */\n        CanvasLayer$2.prototype.getTopLeft = function () {\n            return this.topLeft_;\n        };\n\n        /**\n         * Schedule a requestAnimationFrame callback to updateHandler. If one is\n         * already scheduled, there is no effect.\n         */\n        CanvasLayer$2.prototype.scheduleUpdate = function () {\n            if (this.isAdded_ && !this.requestAnimationFrameId_) {\n                this.requestAnimationFrameId_ = this.requestAnimFrame_.call(global$4, this.requestUpdateFunction_);\n            }\n        };\n    }\n\n    /**\n     * @author kyle / http://nikai.us/\n     */\n\n    var Layer$2 = (function (_BaseLayer) {\n        inherits(Layer, _BaseLayer);\n\n        function Layer(map, dataSet, options) {\n            classCallCheck(this, Layer);\n\n            var _this = possibleConstructorReturn(\n                this,\n                (Layer.__proto__ || Object.getPrototypeOf(Layer)).call(this, map, dataSet, options)\n            );\n\n            var self = _this;\n            var data = null;\n            options = options || {};\n\n            self.init(options);\n            self.argCheck(options);\n\n            var canvasLayerOptions = {\n                map: map,\n                animate: false,\n                updateHandler: function updateHandler() {\n                    self._canvasUpdate();\n                },\n                resolutionScale: resolutionScale,\n            };\n\n            var canvasLayer = (_this.canvasLayer = new CanvasLayer$2(canvasLayerOptions));\n\n            _this.clickEvent = _this.clickEvent.bind(_this);\n            _this.mousemoveEvent = _this.mousemoveEvent.bind(_this);\n            _this.bindEvent();\n            return _this;\n        }\n\n        createClass(Layer, [\n            {\n                key: 'clickEvent',\n                value: function clickEvent(e) {\n                    var pixel = e.pixel;\n                    get(Layer.prototype.__proto__ || Object.getPrototypeOf(Layer.prototype), 'clickEvent', this).call(\n                        this,\n                        pixel,\n                        e\n                    );\n                },\n            },\n            {\n                key: 'mousemoveEvent',\n                value: function mousemoveEvent(e) {\n                    var pixel = e.pixel;\n                    get(\n                        Layer.prototype.__proto__ || Object.getPrototypeOf(Layer.prototype),\n                        'mousemoveEvent',\n                        this\n                    ).call(this, pixel, e);\n                },\n            },\n            {\n                key: 'bindEvent',\n                value: function bindEvent(e) {\n                    var map = this.map;\n\n                    if (this.options.methods) {\n                        if (this.options.methods.click) {\n                            map.setDefaultCursor('default');\n                            map.addListener('click', this.clickEvent);\n                        }\n                        if (this.options.methods.mousemove) {\n                            map.addListener('mousemove', this.mousemoveEvent);\n                        }\n                    }\n                },\n            },\n            {\n                key: 'unbindEvent',\n                value: function unbindEvent(e) {\n                    var map = this.map;\n\n                    if (this.options.methods) {\n                        if (this.options.methods.click) {\n                            map.removeListener('click', this.clickEvent);\n                        }\n                        if (this.options.methods.mousemove) {\n                            map.removeListener('mousemove', this.mousemoveEvent);\n                        }\n                    }\n                },\n            },\n            {\n                key: 'getContext',\n                value: function getContext() {\n                    return this.canvasLayer.canvas.getContext(this.context);\n                },\n            },\n            {\n                key: '_canvasUpdate',\n                value: function _canvasUpdate(time) {\n                    if (!this.canvasLayer) {\n                        return;\n                    }\n\n                    var self = this;\n\n                    var animationOptions = self.options.animation;\n\n                    var context = this.getContext();\n\n                    if (self.isEnabledTime()) {\n                        if (time === undefined) {\n                            clear(context);\n                            return;\n                        }\n                        if (this.context == '2d') {\n                            context.save();\n                            context.globalCompositeOperation = 'destination-out';\n                            context.fillStyle = 'rgba(0, 0, 0, .1)';\n                            context.fillRect(0, 0, context.canvas.width, context.canvas.height);\n                            context.restore();\n                        }\n                    } else {\n                        clear(context);\n                    }\n\n                    if (this.context == '2d') {\n                        for (var key in self.options) {\n                            context[key] = self.options[key];\n                        }\n                    } else {\n                        context.clear(context.COLOR_BUFFER_BIT);\n                    }\n\n                    if (\n                        (self.options.minZoom && map.getZoom() < self.options.minZoom) ||\n                        (self.options.maxZoom && map.getZoom() > self.options.maxZoom)\n                    ) {\n                        return;\n                    }\n\n                    var scale = 1;\n                    if (this.context != '2d') {\n                        scale = this.canvasLayer.devicePixelRatio;\n                    }\n\n                    var map = this.map;\n                    var mapProjection = map.getProjection();\n                    var scale = Math.pow(2, map.zoom) * resolutionScale;\n                    var offset = mapProjection.fromLatLngToPoint(this.canvasLayer.getTopLeft());\n                    var dataGetOptions = {\n                        //fromColumn: self.options.coordType == 'bd09mc' ? 'coordinates' : 'coordinates_mercator',\n                        transferCoordinate: function transferCoordinate(coordinate) {\n                            var latLng = new google.maps.LatLng(coordinate[1], coordinate[0]);\n                            var worldPoint = mapProjection.fromLatLngToPoint(latLng);\n                            var pixel = {\n                                x: (worldPoint.x - offset.x) * scale,\n                                y: (worldPoint.y - offset.y) * scale,\n                            };\n                            return [pixel.x, pixel.y];\n                        },\n                    };\n\n                    if (time !== undefined) {\n                        dataGetOptions.filter = function (item) {\n                            var trails = animationOptions.trails || 10;\n                            if (time && item.time > time - trails && item.time < time) {\n                                return true;\n                            } else {\n                                return false;\n                            }\n                        };\n                    }\n\n                    // get data from data set\n                    var data = self.dataSet.get(dataGetOptions);\n\n                    this.processData(data);\n\n                    var latLng = new google.maps.LatLng(0, 0);\n                    var worldPoint = mapProjection.fromLatLngToPoint(latLng);\n                    var pixel = {\n                        x: (worldPoint.x - offset.x) * scale,\n                        y: (worldPoint.y - offset.y) * scale,\n                    };\n\n                    if (self.options.unit == 'm' && self.options.size) {\n                        self.options._size = self.options.size / zoomUnit;\n                    } else {\n                        self.options._size = self.options.size;\n                    }\n\n                    this.drawContext(context, new DataSet(data), self.options, pixel);\n\n                    //console.timeEnd('draw');\n\n                    //console.timeEnd('update')\n                    self.options.updateCallback && self.options.updateCallback(time);\n                },\n            },\n            {\n                key: 'init',\n                value: function init(options) {\n                    var self = this;\n\n                    self.options = options;\n\n                    this.initDataRange(options);\n\n                    this.context = self.options.context || '2d';\n\n                    if (self.options.zIndex) {\n                        this.canvasLayer && this.canvasLayer.setZIndex(self.options.zIndex);\n                    }\n\n                    this.initAnimator();\n                },\n            },\n            {\n                key: 'addAnimatorEvent',\n                value: function addAnimatorEvent() {\n                    this.map.addListener('movestart', this.animatorMovestartEvent.bind(this));\n                    this.map.addListener('moveend', this.animatorMoveendEvent.bind(this));\n                },\n            },\n            {\n                key: 'show',\n                value: function show() {\n                    this.map.addOverlay(this.canvasLayer);\n                },\n            },\n            {\n                key: 'hide',\n                value: function hide() {\n                    this.map.removeOverlay(this.canvasLayer);\n                },\n            },\n            {\n                key: 'draw',\n                value: function draw() {\n                    self.canvasLayer.draw();\n                },\n            },\n        ]);\n        return Layer;\n    })(BaseLayer);\n\n    /**\n     * @author kyle / http://nikai.us/\n     */\n\n    var geojson = {\n        getDataSet: function getDataSet(geoJson) {\n            var data = [];\n            var features = geoJson.features;\n            for (var i = 0; i < features.length; i++) {\n                var feature = features[i];\n                var geometry = feature.geometry;\n                var properties = feature.properties;\n                var item = {};\n                for (var key in properties) {\n                    item[key] = properties[key];\n                }\n                item.geometry = geometry;\n                data.push(item);\n            }\n            return new DataSet(data);\n        },\n    };\n\n    /**\n     * @author kyle / http://nikai.us/\n     */\n\n    var csv = {\n        CSVToArray: function CSVToArray(strData, strDelimiter) {\n            // Check to see if the delimiter is defined. If not,\n            // then default to comma.\n            strDelimiter = strDelimiter || ',';\n\n            // Create a regular expression to parse the CSV values.\n            var objPattern = new RegExp(\n                // Delimiters.\n                '(\\\\' +\n                    strDelimiter +\n                    '|\\\\r?\\\\n|\\\\r|^)' +\n                    // Quoted fields.\n                    '(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|' +\n                    // Standard fields.\n                    '([^\"\\\\' +\n                    strDelimiter +\n                    '\\\\r\\\\n]*))',\n                'gi'\n            );\n\n            // Create an array to hold our data. Give the array\n            // a default empty first row.\n            var arrData = [[]];\n\n            // Create an array to hold our individual pattern\n            // matching groups.\n            var arrMatches = null;\n\n            // Keep looping over the regular expression matches\n            // until we can no longer find a match.\n            while ((arrMatches = objPattern.exec(strData))) {\n                // Get the delimiter that was found.\n                var strMatchedDelimiter = arrMatches[1];\n\n                // Check to see if the given delimiter has a length\n                // (is not the start of string) and if it matches\n                // field delimiter. If id does not, then we know\n                // that this delimiter is a row delimiter.\n                if (strMatchedDelimiter.length && strMatchedDelimiter !== strDelimiter) {\n                    // Since we have reached a new row of data,\n                    // add an empty row to our data array.\n                    arrData.push([]);\n                }\n\n                var strMatchedValue;\n\n                // Now that we have our delimiter out of the way,\n                // let's check to see which kind of value we\n                // captured (quoted or unquoted).\n                if (arrMatches[2]) {\n                    // We found a quoted value. When we capture\n                    // this value, unescape any double quotes.\n                    strMatchedValue = arrMatches[2].replace(new RegExp('\"\"', 'g'), '\"');\n                } else {\n                    // We found a non-quoted value.\n                    strMatchedValue = arrMatches[3];\n                }\n\n                // Now that we have our value string, let's add\n                // it to the data array.\n                arrData[arrData.length - 1].push(strMatchedValue);\n            }\n\n            // Return the parsed data.\n            return arrData;\n        },\n\n        getDataSet: function getDataSet(csvStr) {\n            var arr = this.CSVToArray(csvStr, ',');\n\n            var data = [];\n\n            var header = arr[0];\n\n            for (var i = 1; i < arr.length - 1; i++) {\n                var line = arr[i];\n                var item = {};\n                for (var j = 0; j < line.length; j++) {\n                    var value = line[j];\n                    if (header[j] == 'geometry') {\n                        value = JSON.parse(value);\n                    }\n                    item[header[j]] = value;\n                }\n                data.push(item);\n            }\n\n            return new DataSet(data);\n        },\n    };\n\n    exports.version = version;\n    exports.canvasClear = clear;\n    exports.canvasResolutionScale = resolutionScale$1;\n    exports.canvasDrawSimple = drawSimple;\n    exports.canvasDrawHeatmap = drawHeatmap;\n    exports.canvasDrawGrid = drawGrid;\n    exports.canvasDrawHoneycomb = drawHoneycomb;\n    exports.webglDrawSimple = webglDrawSimple;\n    exports.webglDrawPoint = point;\n    exports.webglDrawLine = line;\n    exports.webglDrawPolygon = polygon;\n    exports.utilCityCenter = cityCenter;\n    exports.utilCurve = curve;\n    exports.utilForceEdgeBundling = ForceEdgeBundling;\n    exports.utilDataRangeIntensity = Intensity;\n    exports.utilDataRangeCategory = Category;\n    exports.utilDataRangeChoropleth = Choropleth;\n    exports.Map = MapHelper;\n    exports.baiduMapCanvasLayer = CanvasLayer;\n    exports.baiduMapAnimationLayer = AnimationLayer;\n    exports.baiduMapLayer = Layer;\n    exports.googleMapCanvasLayer = CanvasLayer$2;\n    exports.googleMapLayer = Layer$2;\n    exports.DataSet = DataSet;\n    exports.geojson = geojson;\n    exports.csv = csv;\n\n    Object.defineProperty(exports, '__esModule', {\n        value: true,\n    });\n});\n","html":"","externalScripts":"https://cdn.jsdelivr.net/npm/echarts@5/dist/extension/bmap.min.js,https://api.map.baidu.com/api?v=3.0&ak=HzuYrxViWWHGdz1XiBCOukN4rKmmLju7","updaterUID":"bd-405506747","theme":"","layout":"","viewCount":0,"userName":"s***a","commentCount":0,"starCount":0,"isStared":0,"thumbnailURL":"https://www.makeapie.com/ecg-storage/ec_gallery_thumbnail/xzwsDCo7bo.png?v=1625900929371","isCustomThumbnail":1,"builtinTags":["category-work"],"customTags":[],"updaterUserName":"s***a"}}